import { NonterminalKind, TerminalKind } from '@nomicfoundation/slang/cst';
import { isBinaryOperation } from './is-binary-operation.js';
import { Expression } from '../slang-nodes/Expression.js';
import { TupleExpression } from '../slang-nodes/TupleExpression.js';
import { TupleValues } from '../slang-nodes/TupleValues.js';
import { TupleValue } from '../slang-nodes/TupleValue.js';
export function createHugFunction(huggableOperators) {
    const operators = new Set(huggableOperators);
    return (node) => {
        if (node.variant.kind !== TerminalKind.Identifier &&
            isBinaryOperation(node.variant) &&
            operators.has(node.variant.operator)) {
            const { loc } = node;
            return Object.assign(Object.create(Expression.prototype), {
                kind: NonterminalKind.Expression,
                loc: Object.assign({}, loc),
                comments: [],
                variant: Object.assign(Object.create(TupleExpression.prototype), {
                    kind: NonterminalKind.TupleExpression,
                    loc: Object.assign({}, loc),
                    comments: [],
                    items: Object.assign(Object.create(TupleValues.prototype), {
                        kind: NonterminalKind.TupleValues,
                        loc: Object.assign({}, loc),
                        comments: [],
                        items: [
                            Object.assign(Object.create(TupleValue.prototype), {
                                kind: NonterminalKind.TupleValue,
                                loc: Object.assign({}, loc),
                                comments: [],
                                expression: node
                            })
                        ],
                        separators: []
                    })
                })
            });
        }
        return node;
    };
}
//# sourceMappingURL=create-hug-function.js.map