import { NonterminalKind } from '@nomicfoundation/slang/cst';
import { getNodeMetadata, updateMetadata } from '../slang-utils/metadata.js';
import { ExpressionStatement } from './ExpressionStatement.js';
import { VariableDeclarationStatement } from './VariableDeclarationStatement.js';
import { TupleDeconstructionStatement } from './TupleDeconstructionStatement.js';
import { IfStatement } from './IfStatement.js';
import { ForStatement } from './ForStatement.js';
import { WhileStatement } from './WhileStatement.js';
import { DoWhileStatement } from './DoWhileStatement.js';
import { ContinueStatement } from './ContinueStatement.js';
import { BreakStatement } from './BreakStatement.js';
import { ReturnStatement } from './ReturnStatement.js';
import { ThrowStatement } from './ThrowStatement.js';
import { EmitStatement } from './EmitStatement.js';
import { TryStatement } from './TryStatement.js';
import { RevertStatement } from './RevertStatement.js';
import { AssemblyStatement } from './AssemblyStatement.js';
import { Block } from './Block.js';
import { UncheckedBlock } from './UncheckedBlock.js';
export class Statement {
    constructor(ast, options) {
        this.kind = NonterminalKind.Statement;
        let metadata = getNodeMetadata(ast);
        switch (ast.variant.cst.kind) {
            case NonterminalKind.ExpressionStatement:
                this.variant = new ExpressionStatement(ast.variant, options);
                break;
            case NonterminalKind.VariableDeclarationStatement:
                this.variant = new VariableDeclarationStatement(ast.variant, options);
                break;
            case NonterminalKind.TupleDeconstructionStatement:
                this.variant = new TupleDeconstructionStatement(ast.variant, options);
                break;
            case NonterminalKind.IfStatement:
                this.variant = new IfStatement(ast.variant, options);
                break;
            case NonterminalKind.ForStatement:
                this.variant = new ForStatement(ast.variant, options);
                break;
            case NonterminalKind.WhileStatement:
                this.variant = new WhileStatement(ast.variant, options);
                break;
            case NonterminalKind.DoWhileStatement:
                this.variant = new DoWhileStatement(ast.variant, options);
                break;
            case NonterminalKind.ContinueStatement:
                this.variant = new ContinueStatement(ast.variant);
                break;
            case NonterminalKind.BreakStatement:
                this.variant = new BreakStatement(ast.variant);
                break;
            case NonterminalKind.ReturnStatement:
                this.variant = new ReturnStatement(ast.variant, options);
                break;
            case NonterminalKind.ThrowStatement:
                this.variant = new ThrowStatement(ast.variant);
                break;
            case NonterminalKind.EmitStatement:
                this.variant = new EmitStatement(ast.variant, options);
                break;
            case NonterminalKind.TryStatement:
                this.variant = new TryStatement(ast.variant, options);
                break;
            case NonterminalKind.RevertStatement:
                this.variant = new RevertStatement(ast.variant, options);
                break;
            case NonterminalKind.AssemblyStatement:
                this.variant = new AssemblyStatement(ast.variant, options);
                break;
            case NonterminalKind.Block:
                this.variant = new Block(ast.variant, options);
                break;
            case NonterminalKind.UncheckedBlock:
                this.variant = new UncheckedBlock(ast.variant, options);
                break;
            default:
                throw new Error(`Unexpected variant: ${ast.variant.cst.kind}`);
        }
        metadata = updateMetadata(metadata, [this.variant]);
        this.comments = metadata.comments;
        this.loc = metadata.loc;
    }
    print(path, print) {
        return path.call(print, 'variant');
    }
}
//# sourceMappingURL=Statement.js.map