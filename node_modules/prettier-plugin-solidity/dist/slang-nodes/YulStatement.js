import { NonterminalKind } from '@nomicfoundation/slang/cst';
import { getNodeMetadata, updateMetadata } from '../slang-utils/metadata.js';
import { YulBlock } from './YulBlock.js';
import { YulFunctionDefinition } from './YulFunctionDefinition.js';
import { YulVariableDeclarationStatement } from './YulVariableDeclarationStatement.js';
import { YulVariableAssignmentStatement } from './YulVariableAssignmentStatement.js';
import { YulStackAssignmentStatement } from './YulStackAssignmentStatement.js';
import { YulIfStatement } from './YulIfStatement.js';
import { YulForStatement } from './YulForStatement.js';
import { YulSwitchStatement } from './YulSwitchStatement.js';
import { YulLeaveStatement } from './YulLeaveStatement.js';
import { YulBreakStatement } from './YulBreakStatement.js';
import { YulContinueStatement } from './YulContinueStatement.js';
import { YulLabel } from './YulLabel.js';
import { YulExpression } from './YulExpression.js';
export class YulStatement {
    constructor(ast, options) {
        this.kind = NonterminalKind.YulStatement;
        let metadata = getNodeMetadata(ast);
        switch (ast.variant.cst.kind) {
            case NonterminalKind.YulBlock:
                this.variant = new YulBlock(ast.variant, options);
                break;
            case NonterminalKind.YulFunctionDefinition:
                this.variant = new YulFunctionDefinition(ast.variant, options);
                break;
            case NonterminalKind.YulVariableDeclarationStatement:
                this.variant = new YulVariableDeclarationStatement(ast.variant, options);
                break;
            case NonterminalKind.YulVariableAssignmentStatement:
                this.variant = new YulVariableAssignmentStatement(ast.variant, options);
                break;
            case NonterminalKind.YulStackAssignmentStatement:
                this.variant = new YulStackAssignmentStatement(ast.variant);
                break;
            case NonterminalKind.YulIfStatement:
                this.variant = new YulIfStatement(ast.variant, options);
                break;
            case NonterminalKind.YulForStatement:
                this.variant = new YulForStatement(ast.variant, options);
                break;
            case NonterminalKind.YulSwitchStatement:
                this.variant = new YulSwitchStatement(ast.variant, options);
                break;
            case NonterminalKind.YulLeaveStatement:
                this.variant = new YulLeaveStatement(ast.variant);
                break;
            case NonterminalKind.YulBreakStatement:
                this.variant = new YulBreakStatement(ast.variant);
                break;
            case NonterminalKind.YulContinueStatement:
                this.variant = new YulContinueStatement(ast.variant);
                break;
            case NonterminalKind.YulLabel:
                this.variant = new YulLabel(ast.variant);
                break;
            case NonterminalKind.YulExpression:
                this.variant = new YulExpression(ast.variant, options);
                break;
            default:
                throw new Error(`Unexpected variant: ${ast.variant.cst.kind}`);
        }
        metadata = updateMetadata(metadata, [this.variant]);
        this.comments = metadata.comments;
        this.loc = metadata.loc;
    }
    print(path, print) {
        return path.call(print, 'variant');
    }
}
//# sourceMappingURL=YulStatement.js.map