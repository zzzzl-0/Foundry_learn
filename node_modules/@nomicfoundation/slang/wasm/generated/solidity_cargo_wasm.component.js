// @ts-nocheck

import { environment, exit as exit$1, stderr, stdin, stdout } from '@bytecodealliance/preview2-shim/cli';
import { preopens, types } from '@bytecodealliance/preview2-shim/filesystem';
import { error, streams } from '@bytecodealliance/preview2-shim/io';
import { random } from '@bytecodealliance/preview2-shim/random';
const { getEnvironment } = environment;
const { exit } = exit$1;
const { getStderr } = stderr;
const { getStdin } = stdin;
const { getStdout } = stdout;
const { getDirectories } = preopens;
const { Descriptor,
  filesystemErrorCode } = types;
const { Error: Error$1 } = error;
const { InputStream,
  OutputStream } = streams;
const { getRandomBytes } = random;

let curResourceBorrows = [];

let dv = new DataView(new ArrayBuffer());
const dataView = mem => dv.buffer === mem.buffer ? dv : dv = new DataView(mem.buffer);

const emptyFunc = () => {};

const isNode = typeof process !== 'undefined' && process.versions && process.versions.node;
let _fs;
async function fetchCompile (url) {
  if (isNode) {
    _fs = _fs || await import('node:fs/promises');
    return WebAssembly.compile(await _fs.readFile(url));
  }
  return fetch(url).then(WebAssembly.compileStreaming);
}

function finalizationRegistryCreate (unregister) {
  if (typeof FinalizationRegistry === 'undefined') {
    return { unregister () {} };
  }
  return new FinalizationRegistry(unregister);
}

function getErrorPayload(e) {
  if (e && hasOwnProperty.call(e, 'payload')) return e.payload;
  if (e instanceof Error) throw e;
  return e;
}

const handleTables = [];

const hasOwnProperty = Object.prototype.hasOwnProperty;

const instantiateCore = WebAssembly.instantiate;

const T_FLAG = 1 << 30;

function rscTableCreateOwn (table, rep) {
  const free = table[0] & ~T_FLAG;
  if (free === 0) {
    table.push(0);
    table.push(rep | T_FLAG);
    return (table.length >> 1) - 1;
  }
  table[0] = table[free << 1];
  table[free << 1] = 0;
  table[(free << 1) + 1] = rep | T_FLAG;
  return free;
}

function rscTableRemove (table, handle) {
  const scope = table[handle << 1];
  const val = table[(handle << 1) + 1];
  const own = (val & T_FLAG) !== 0;
  const rep = val & ~T_FLAG;
  if (val === 0 || (scope & T_FLAG) !== 0) throw new TypeError('Invalid handle');
  table[handle << 1] = table[0] | T_FLAG;
  table[0] = handle | T_FLAG;
  return { rep, scope, own };
}

const symbolCabiDispose = Symbol.for('cabiDispose');

const symbolRscHandle = Symbol('handle');

const symbolRscRep = Symbol.for('cabiRep');

const symbolDispose = Symbol.dispose || Symbol.for('dispose');

const toUint64 = val => BigInt.asUintN(64, BigInt(val));

function toUint32(val) {
  return val >>> 0;
}

const utf8Decoder = new TextDecoder();

const utf8Encoder = new TextEncoder();

let utf8EncodedLen = 0;
function utf8Encode(s, realloc, memory) {
  if (typeof s !== 'string') throw new TypeError('expected a string');
  if (s.length === 0) {
    utf8EncodedLen = 0;
    return 1;
  }
  let buf = utf8Encoder.encode(s);
  let ptr = realloc(0, 0, 1, buf.length);
  new Uint8Array(memory.buffer).set(buf, ptr);
  utf8EncodedLen = buf.length;
  return ptr;
}

const nodeJSCustomInspectSymbol = Symbol.for("nodejs.util.inspect.custom");


let exports0;
let exports1;
const handleTable1 = [T_FLAG, 0];
const captureTable1= new Map();
let captureCnt1 = 0;
handleTables[1] = handleTable1;

function trampoline38() {
  const ret = getStderr();
  if (!(ret instanceof OutputStream)) {
    throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable1, rep);
  }
  return handle0;
}

const handleTable2 = [T_FLAG, 0];
const captureTable2= new Map();
let captureCnt2 = 0;
handleTables[2] = handleTable2;

function trampoline39() {
  const ret = getStdin();
  if (!(ret instanceof InputStream)) {
    throw new TypeError('Resource error: Not a valid "InputStream" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt2;
    captureTable2.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable2, rep);
  }
  return handle0;
}


function trampoline40() {
  const ret = getStdout();
  if (!(ret instanceof OutputStream)) {
    throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable1, rep);
  }
  return handle0;
}


function trampoline41(arg0) {
  let variant0;
  if (arg0) {
    variant0= {
      tag: 'err',
      val: undefined
    };
  } else {
    variant0= {
      tag: 'ok',
      val: undefined
    };
  }
  exit(variant0);
}

let exports2;
let memory0;
let realloc0;

function trampoline42(arg0) {
  const ret = getEnvironment();
  var vec3 = ret;
  var len3 = vec3.length;
  var result3 = realloc0(0, 0, 4, len3 * 16);
  for (let i = 0; i < vec3.length; i++) {
    const e = vec3[i];
    const base = result3 + i * 16;var [tuple0_0, tuple0_1] = e;
    var ptr1 = utf8Encode(tuple0_0, realloc0, memory0);
    var len1 = utf8EncodedLen;
    dataView(memory0).setInt32(base + 4, len1, true);
    dataView(memory0).setInt32(base + 0, ptr1, true);
    var ptr2 = utf8Encode(tuple0_1, realloc0, memory0);
    var len2 = utf8EncodedLen;
    dataView(memory0).setInt32(base + 12, len2, true);
    dataView(memory0).setInt32(base + 8, ptr2, true);
  }
  dataView(memory0).setInt32(arg0 + 4, len3, true);
  dataView(memory0).setInt32(arg0 + 0, result3, true);
}

const handleTable3 = [T_FLAG, 0];
const captureTable3= new Map();
let captureCnt3 = 0;
handleTables[3] = handleTable3;

function trampoline43(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.writeViaStream(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      if (!(e instanceof OutputStream)) {
        throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
      }
      var handle3 = e[symbolRscHandle];
      if (!handle3) {
        const rep = e[symbolRscRep] || ++captureCnt1;
        captureTable1.set(rep, e);
        handle3 = rscTableCreateOwn(handleTable1, rep);
      }
      dataView(memory0).setInt32(arg2 + 4, handle3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 4, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}


function trampoline44(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.appendViaStream()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      if (!(e instanceof OutputStream)) {
        throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
      }
      var handle3 = e[symbolRscHandle];
      if (!handle3) {
        const rep = e[symbolRscRep] || ++captureCnt1;
        captureTable1.set(rep, e);
        handle3 = rscTableCreateOwn(handleTable1, rep);
      }
      dataView(memory0).setInt32(arg1 + 4, handle3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}


function trampoline45(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.getType()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'block-device': {
          enum3 = 1;
          break;
        }
        case 'character-device': {
          enum3 = 2;
          break;
        }
        case 'directory': {
          enum3 = 3;
          break;
        }
        case 'fifo': {
          enum3 = 4;
          break;
        }
        case 'symbolic-link': {
          enum3 = 5;
          break;
        }
        case 'regular-file': {
          enum3 = 6;
          break;
        }
        case 'socket': {
          enum3 = 7;
          break;
        }
        default: {
          
          throw new TypeError(`"${val3}" is not one of the cases of descriptor-type`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}


function trampoline46(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.stat()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant12 = ret;
  switch (variant12.tag) {
    case 'ok': {
      const e = variant12.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var {type: v3_0, linkCount: v3_1, size: v3_2, dataAccessTimestamp: v3_3, dataModificationTimestamp: v3_4, statusChangeTimestamp: v3_5 } = e;
      var val4 = v3_0;
      let enum4;
      switch (val4) {
        case 'unknown': {
          enum4 = 0;
          break;
        }
        case 'block-device': {
          enum4 = 1;
          break;
        }
        case 'character-device': {
          enum4 = 2;
          break;
        }
        case 'directory': {
          enum4 = 3;
          break;
        }
        case 'fifo': {
          enum4 = 4;
          break;
        }
        case 'symbolic-link': {
          enum4 = 5;
          break;
        }
        case 'regular-file': {
          enum4 = 6;
          break;
        }
        case 'socket': {
          enum4 = 7;
          break;
        }
        default: {
          
          throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum4, true);
      dataView(memory0).setBigInt64(arg1 + 16, toUint64(v3_1), true);
      dataView(memory0).setBigInt64(arg1 + 24, toUint64(v3_2), true);
      var variant6 = v3_3;
      if (variant6 === null || variant6=== undefined) {
        dataView(memory0).setInt8(arg1 + 32, 0, true);
      } else {
        const e = variant6;
        dataView(memory0).setInt8(arg1 + 32, 1, true);
        var {seconds: v5_0, nanoseconds: v5_1 } = e;
        dataView(memory0).setBigInt64(arg1 + 40, toUint64(v5_0), true);
        dataView(memory0).setInt32(arg1 + 48, toUint32(v5_1), true);
      }
      var variant8 = v3_4;
      if (variant8 === null || variant8=== undefined) {
        dataView(memory0).setInt8(arg1 + 56, 0, true);
      } else {
        const e = variant8;
        dataView(memory0).setInt8(arg1 + 56, 1, true);
        var {seconds: v7_0, nanoseconds: v7_1 } = e;
        dataView(memory0).setBigInt64(arg1 + 64, toUint64(v7_0), true);
        dataView(memory0).setInt32(arg1 + 72, toUint32(v7_1), true);
      }
      var variant10 = v3_5;
      if (variant10 === null || variant10=== undefined) {
        dataView(memory0).setInt8(arg1 + 80, 0, true);
      } else {
        const e = variant10;
        dataView(memory0).setInt8(arg1 + 80, 1, true);
        var {seconds: v9_0, nanoseconds: v9_1 } = e;
        dataView(memory0).setBigInt64(arg1 + 88, toUint64(v9_0), true);
        dataView(memory0).setInt32(arg1 + 96, toUint32(v9_1), true);
      }
      break;
    }
    case 'err': {
      const e = variant12.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val11 = e;
      let enum11;
      switch (val11) {
        case 'access': {
          enum11 = 0;
          break;
        }
        case 'would-block': {
          enum11 = 1;
          break;
        }
        case 'already': {
          enum11 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum11 = 3;
          break;
        }
        case 'busy': {
          enum11 = 4;
          break;
        }
        case 'deadlock': {
          enum11 = 5;
          break;
        }
        case 'quota': {
          enum11 = 6;
          break;
        }
        case 'exist': {
          enum11 = 7;
          break;
        }
        case 'file-too-large': {
          enum11 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum11 = 9;
          break;
        }
        case 'in-progress': {
          enum11 = 10;
          break;
        }
        case 'interrupted': {
          enum11 = 11;
          break;
        }
        case 'invalid': {
          enum11 = 12;
          break;
        }
        case 'io': {
          enum11 = 13;
          break;
        }
        case 'is-directory': {
          enum11 = 14;
          break;
        }
        case 'loop': {
          enum11 = 15;
          break;
        }
        case 'too-many-links': {
          enum11 = 16;
          break;
        }
        case 'message-size': {
          enum11 = 17;
          break;
        }
        case 'name-too-long': {
          enum11 = 18;
          break;
        }
        case 'no-device': {
          enum11 = 19;
          break;
        }
        case 'no-entry': {
          enum11 = 20;
          break;
        }
        case 'no-lock': {
          enum11 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum11 = 22;
          break;
        }
        case 'insufficient-space': {
          enum11 = 23;
          break;
        }
        case 'not-directory': {
          enum11 = 24;
          break;
        }
        case 'not-empty': {
          enum11 = 25;
          break;
        }
        case 'not-recoverable': {
          enum11 = 26;
          break;
        }
        case 'unsupported': {
          enum11 = 27;
          break;
        }
        case 'no-tty': {
          enum11 = 28;
          break;
        }
        case 'no-such-device': {
          enum11 = 29;
          break;
        }
        case 'overflow': {
          enum11 = 30;
          break;
        }
        case 'not-permitted': {
          enum11 = 31;
          break;
        }
        case 'pipe': {
          enum11 = 32;
          break;
        }
        case 'read-only': {
          enum11 = 33;
          break;
        }
        case 'invalid-seek': {
          enum11 = 34;
          break;
        }
        case 'text-file-busy': {
          enum11 = 35;
          break;
        }
        case 'cross-device': {
          enum11 = 36;
          break;
        }
        default: {
          
          throw new TypeError(`"${val11}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum11, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}

const handleTable0 = [T_FLAG, 0];
const captureTable0= new Map();
let captureCnt0 = 0;
handleTables[0] = handleTable0;

function trampoline47(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable0[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable0.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Error$1.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  const ret = filesystemErrorCode(rsc0);
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant4 = ret;
  if (variant4 === null || variant4=== undefined) {
    dataView(memory0).setInt8(arg1 + 0, 0, true);
  } else {
    const e = variant4;
    dataView(memory0).setInt8(arg1 + 0, 1, true);
    var val3 = e;
    let enum3;
    switch (val3) {
      case 'access': {
        enum3 = 0;
        break;
      }
      case 'would-block': {
        enum3 = 1;
        break;
      }
      case 'already': {
        enum3 = 2;
        break;
      }
      case 'bad-descriptor': {
        enum3 = 3;
        break;
      }
      case 'busy': {
        enum3 = 4;
        break;
      }
      case 'deadlock': {
        enum3 = 5;
        break;
      }
      case 'quota': {
        enum3 = 6;
        break;
      }
      case 'exist': {
        enum3 = 7;
        break;
      }
      case 'file-too-large': {
        enum3 = 8;
        break;
      }
      case 'illegal-byte-sequence': {
        enum3 = 9;
        break;
      }
      case 'in-progress': {
        enum3 = 10;
        break;
      }
      case 'interrupted': {
        enum3 = 11;
        break;
      }
      case 'invalid': {
        enum3 = 12;
        break;
      }
      case 'io': {
        enum3 = 13;
        break;
      }
      case 'is-directory': {
        enum3 = 14;
        break;
      }
      case 'loop': {
        enum3 = 15;
        break;
      }
      case 'too-many-links': {
        enum3 = 16;
        break;
      }
      case 'message-size': {
        enum3 = 17;
        break;
      }
      case 'name-too-long': {
        enum3 = 18;
        break;
      }
      case 'no-device': {
        enum3 = 19;
        break;
      }
      case 'no-entry': {
        enum3 = 20;
        break;
      }
      case 'no-lock': {
        enum3 = 21;
        break;
      }
      case 'insufficient-memory': {
        enum3 = 22;
        break;
      }
      case 'insufficient-space': {
        enum3 = 23;
        break;
      }
      case 'not-directory': {
        enum3 = 24;
        break;
      }
      case 'not-empty': {
        enum3 = 25;
        break;
      }
      case 'not-recoverable': {
        enum3 = 26;
        break;
      }
      case 'unsupported': {
        enum3 = 27;
        break;
      }
      case 'no-tty': {
        enum3 = 28;
        break;
      }
      case 'no-such-device': {
        enum3 = 29;
        break;
      }
      case 'overflow': {
        enum3 = 30;
        break;
      }
      case 'not-permitted': {
        enum3 = 31;
        break;
      }
      case 'pipe': {
        enum3 = 32;
        break;
      }
      case 'read-only': {
        enum3 = 33;
        break;
      }
      case 'invalid-seek': {
        enum3 = 34;
        break;
      }
      case 'text-file-busy': {
        enum3 = 35;
        break;
      }
      case 'cross-device': {
        enum3 = 36;
        break;
      }
      default: {
        
        throw new TypeError(`"${val3}" is not one of the cases of error-code`);
      }
    }
    dataView(memory0).setInt8(arg1 + 1, enum3, true);
  }
}


function trampoline48(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable1.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.checkWrite()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg1 + 8, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg1 + 12, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg1 + 8, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}


function trampoline49(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable1.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.write(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg3 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}


function trampoline50(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable1.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.blockingWriteAndFlush(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg3 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}


function trampoline51(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable1.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let ret;
  try {
    ret = { tag: 'ok', val: rsc0.blockingFlush()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg1 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg1 + 8, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
}


function trampoline52(arg0, arg1) {
  const ret = getRandomBytes(BigInt.asUintN(64, arg0));
  var val0 = ret;
  var len0 = val0.byteLength;
  var ptr0 = realloc0(0, 0, 1, len0 * 1);
  var src0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, len0 * 1);
  (new Uint8Array(memory0.buffer, ptr0, len0 * 1)).set(src0);
  dataView(memory0).setInt32(arg1 + 4, len0, true);
  dataView(memory0).setInt32(arg1 + 0, ptr0, true);
}


function trampoline53(arg0) {
  const ret = getDirectories();
  var vec3 = ret;
  var len3 = vec3.length;
  var result3 = realloc0(0, 0, 4, len3 * 12);
  for (let i = 0; i < vec3.length; i++) {
    const e = vec3[i];
    const base = result3 + i * 12;var [tuple0_0, tuple0_1] = e;
    if (!(tuple0_0 instanceof Descriptor)) {
      throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
    }
    var handle1 = tuple0_0[symbolRscHandle];
    if (!handle1) {
      const rep = tuple0_0[symbolRscRep] || ++captureCnt3;
      captureTable3.set(rep, tuple0_0);
      handle1 = rscTableCreateOwn(handleTable3, rep);
    }
    dataView(memory0).setInt32(base + 0, handle1, true);
    var ptr2 = utf8Encode(tuple0_1, realloc0, memory0);
    var len2 = utf8EncodedLen;
    dataView(memory0).setInt32(base + 8, len2, true);
    dataView(memory0).setInt32(base + 4, ptr2, true);
  }
  dataView(memory0).setInt32(arg0 + 4, len3, true);
  dataView(memory0).setInt32(arg0 + 0, result3, true);
}

let exports3;
let postReturn0;
let postReturn1;
let realloc1;
let postReturn2;
let postReturn3;
let postReturn4;
let postReturn5;
let postReturn6;
let postReturn7;
let postReturn8;
let postReturn9;
let cstStaticTerminalKindExtensionsIsIdentifier;

class TerminalKindExtensions{
  constructor () {
    throw new Error('"TerminalKindExtensions" resource does not define a constructor');
  }
}

TerminalKindExtensions.isIdentifier = function isIdentifier(arg0) {
  const ret = cstStaticTerminalKindExtensionsIsIdentifier(terminalKindCABI[arg0]);
  var bool0 = ret;
  return !!bool0;
};
let cstStaticTerminalKindExtensionsIsTrivia;

TerminalKindExtensions.isTrivia = function isTrivia(arg0) {
  const ret = cstStaticTerminalKindExtensionsIsTrivia(terminalKindCABI[arg0]);
  var bool0 = ret;
  return !!bool0;
};
let cstStaticTerminalKindExtensionsIsValid;

TerminalKindExtensions.isValid = function isValid(arg0) {
  const ret = cstStaticTerminalKindExtensionsIsValid(terminalKindCABI[arg0]);
  var bool0 = ret;
  return !!bool0;
};
const handleTable4 = [T_FLAG, 0];
const finalizationRegistry4 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable4, handle);
  exports0['18'](rep);
});

handleTables[4] = handleTable4;
let cstMethodNonterminalNodeId;

class NonterminalNode{
  constructor () {
    throw new Error('"NonterminalNode" resource does not define a constructor');
  }
}

NonterminalNode.prototype[nodeJSCustomInspectSymbol] = function(depth, options, inspect) {
  const original = Object.getPrototypeOf(this)[nodeJSCustomInspectSymbol];
  
  try {
    // Temporarily remove the custom inspect form the object's prototype to avoid infinite recursion:
    delete Object.getPrototypeOf(this)[nodeJSCustomInspectSymbol];
    
    return inspect(this, {
      ...options,
      depth,
      getters: true,
      showHidden: true,
    });
  } finally {
    Object.getPrototypeOf(this)[nodeJSCustomInspectSymbol] = original;
  }
}


Object.defineProperty(NonterminalNode.prototype, "id", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodNonterminalNodeId(handle0);
  return ret >>> 0;
}});
let cstMethodNonterminalNodeKind;

Object.defineProperty(NonterminalNode.prototype, "kind", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodNonterminalNodeKind(handle0);
  return nonterminalKindCABI[ret];
}});
let cstMethodNonterminalNodeTextLength;

Object.defineProperty(NonterminalNode.prototype, "textLength", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodNonterminalNodeTextLength(handle0);
  return {
    utf8: dataView(memory0).getInt32(ret + 0, true) >>> 0,
    utf16: dataView(memory0).getInt32(ret + 4, true) >>> 0,
    line: dataView(memory0).getInt32(ret + 8, true) >>> 0,
    column: dataView(memory0).getInt32(ret + 12, true) >>> 0,
  };
}});
const handleTable5 = [T_FLAG, 0];
const finalizationRegistry5 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable5, handle);
  exports0['19'](rep);
});

handleTables[5] = handleTable5;
let cstMethodNonterminalNodeChildren;

NonterminalNode.prototype.children = function children() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodNonterminalNodeChildren(handle0);
  var len7 = dataView(memory0).getInt32(ret + 4, true);
  var base7 = dataView(memory0).getInt32(ret + 0, true);
  var result7 = [];
  for (let i = 0; i < len7; i++) {
    const base = base7 + i * 12;
    let variant6;
    switch (dataView(memory0).getUint8(base + 4, true)) {
      case 0: {
        var handle3 = dataView(memory0).getInt32(base + 8, true);
        var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
        Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
        finalizationRegistry4.register(rsc2, handle3, rsc2);
        Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
          finalizationRegistry4.unregister(rsc2);
          rscTableRemove(handleTable4, handle3);
          rsc2[symbolDispose] = emptyFunc;
          rsc2[symbolRscHandle] = undefined;
          exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc2;
        break;
      }
      case 1: {
        var handle5 = dataView(memory0).getInt32(base + 8, true);
        var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
        Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
        finalizationRegistry5.register(rsc4, handle5, rsc4);
        Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
          finalizationRegistry5.unregister(rsc4);
          rscTableRemove(handleTable5, handle5);
          rsc4[symbolDispose] = emptyFunc;
          rsc4[symbolRscHandle] = undefined;
          exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc4;
        break;
      }
    }
    result7.push({
      label: edgeLabelCABI[dataView(memory0).getUint8(base + 0, true)],
      node: variant6,
    });
  }
  const retVal = result7;
  postReturn0(ret);
  return retVal;
};
const handleTable7 = [T_FLAG, 0];
const finalizationRegistry7 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable7, handle);
  exports0['21'](rep);
});

handleTables[7] = handleTable7;
let cstMethodNonterminalNodeDescendants;

NonterminalNode.prototype.descendants = function descendants() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodNonterminalNodeDescendants(handle0);
  var handle3 = ret;
  var rsc2 = new.target === CursorIterator ? this : Object.create(CursorIterator.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry7.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry7.unregister(rsc2);
    rscTableRemove(handleTable7, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['21'](handleTable7[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let cstMethodNonterminalNodeUnparse;

NonterminalNode.prototype.unparse = function unparse() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodNonterminalNodeUnparse(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
};
let cstMethodNonterminalNodeToJson;

NonterminalNode.prototype.toJson = function toJson() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodNonterminalNodeToJson(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
};
const handleTable6 = [T_FLAG, 0];
const finalizationRegistry6 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable6, handle);
  exports0['20'](rep);
});

handleTables[6] = handleTable6;
let cstMethodNonterminalNodeCreateCursor;

NonterminalNode.prototype.createCursor = function createCursor(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  var {utf8: v2_0, utf16: v2_1, line: v2_2, column: v2_3 } = arg1;
  const ret = cstMethodNonterminalNodeCreateCursor(handle0, toUint32(v2_0), toUint32(v2_1), toUint32(v2_2), toUint32(v2_3));
  var handle4 = ret;
  var rsc3 = new.target === Cursor ? this : Object.create(Cursor.prototype);
  Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
  finalizationRegistry6.register(rsc3, handle4, rsc3);
  Object.defineProperty(rsc3, symbolDispose, { writable: true, value: function () {
    finalizationRegistry6.unregister(rsc3);
    rscTableRemove(handleTable6, handle4);
    rsc3[symbolDispose] = emptyFunc;
    rsc3[symbolRscHandle] = undefined;
    exports0['20'](handleTable6[(handle4 << 1) + 1] & ~T_FLAG);
  }});
  return rsc3;
};
let cstMethodTerminalNodeId;

class TerminalNode{
  constructor () {
    throw new Error('"TerminalNode" resource does not define a constructor');
  }
}

TerminalNode.prototype[nodeJSCustomInspectSymbol] = function(depth, options, inspect) {
  const original = Object.getPrototypeOf(this)[nodeJSCustomInspectSymbol];
  
  try {
    // Temporarily remove the custom inspect form the object's prototype to avoid infinite recursion:
    delete Object.getPrototypeOf(this)[nodeJSCustomInspectSymbol];
    
    return inspect(this, {
      ...options,
      depth,
      getters: true,
      showHidden: true,
    });
  } finally {
    Object.getPrototypeOf(this)[nodeJSCustomInspectSymbol] = original;
  }
}


Object.defineProperty(TerminalNode.prototype, "id", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable5[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "TerminalNode" resource.');
  }
  var handle0 = handleTable5[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodTerminalNodeId(handle0);
  return ret >>> 0;
}});
let cstMethodTerminalNodeKind;

Object.defineProperty(TerminalNode.prototype, "kind", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable5[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "TerminalNode" resource.');
  }
  var handle0 = handleTable5[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodTerminalNodeKind(handle0);
  return terminalKindCABI[ret];
}});
let cstMethodTerminalNodeTextLength;

Object.defineProperty(TerminalNode.prototype, "textLength", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable5[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "TerminalNode" resource.');
  }
  var handle0 = handleTable5[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodTerminalNodeTextLength(handle0);
  return {
    utf8: dataView(memory0).getInt32(ret + 0, true) >>> 0,
    utf16: dataView(memory0).getInt32(ret + 4, true) >>> 0,
    line: dataView(memory0).getInt32(ret + 8, true) >>> 0,
    column: dataView(memory0).getInt32(ret + 12, true) >>> 0,
  };
}});
let cstMethodTerminalNodeChildren;

TerminalNode.prototype.children = function children() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable5[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "TerminalNode" resource.');
  }
  var handle0 = handleTable5[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodTerminalNodeChildren(handle0);
  var len7 = dataView(memory0).getInt32(ret + 4, true);
  var base7 = dataView(memory0).getInt32(ret + 0, true);
  var result7 = [];
  for (let i = 0; i < len7; i++) {
    const base = base7 + i * 12;
    let variant6;
    switch (dataView(memory0).getUint8(base + 4, true)) {
      case 0: {
        var handle3 = dataView(memory0).getInt32(base + 8, true);
        var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
        Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
        finalizationRegistry4.register(rsc2, handle3, rsc2);
        Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
          finalizationRegistry4.unregister(rsc2);
          rscTableRemove(handleTable4, handle3);
          rsc2[symbolDispose] = emptyFunc;
          rsc2[symbolRscHandle] = undefined;
          exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc2;
        break;
      }
      case 1: {
        var handle5 = dataView(memory0).getInt32(base + 8, true);
        var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
        Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
        finalizationRegistry5.register(rsc4, handle5, rsc4);
        Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
          finalizationRegistry5.unregister(rsc4);
          rscTableRemove(handleTable5, handle5);
          rsc4[symbolDispose] = emptyFunc;
          rsc4[symbolRscHandle] = undefined;
          exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc4;
        break;
      }
    }
    result7.push({
      label: edgeLabelCABI[dataView(memory0).getUint8(base + 0, true)],
      node: variant6,
    });
  }
  const retVal = result7;
  postReturn0(ret);
  return retVal;
};
let cstMethodTerminalNodeDescendants;

TerminalNode.prototype.descendants = function descendants() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable5[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "TerminalNode" resource.');
  }
  var handle0 = handleTable5[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodTerminalNodeDescendants(handle0);
  var handle3 = ret;
  var rsc2 = new.target === CursorIterator ? this : Object.create(CursorIterator.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry7.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry7.unregister(rsc2);
    rscTableRemove(handleTable7, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['21'](handleTable7[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let cstMethodTerminalNodeUnparse;

TerminalNode.prototype.unparse = function unparse() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable5[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "TerminalNode" resource.');
  }
  var handle0 = handleTable5[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodTerminalNodeUnparse(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
};
let cstMethodTerminalNodeToJson;

TerminalNode.prototype.toJson = function toJson() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable5[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "TerminalNode" resource.');
  }
  var handle0 = handleTable5[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodTerminalNodeToJson(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
};
let cstMethodCursorReset;

class Cursor{
  constructor () {
    throw new Error('"Cursor" resource does not define a constructor');
  }
}

Cursor.prototype.reset = function reset() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  cstMethodCursorReset(handle0);
};
let cstMethodCursorComplete;

Cursor.prototype.complete = function complete() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  cstMethodCursorComplete(handle0);
};
let cstMethodCursorIsCompleted;

Cursor.prototype.isCompleted = function isCompleted() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorIsCompleted(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorClone;

Cursor.prototype.clone = function clone() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorClone(handle0);
  var handle3 = ret;
  var rsc2 = new.target === Cursor ? this : Object.create(Cursor.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry6.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry6.unregister(rsc2);
    rscTableRemove(handleTable6, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['20'](handleTable6[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let cstMethodCursorSpawn;

Cursor.prototype.spawn = function spawn() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorSpawn(handle0);
  var handle3 = ret;
  var rsc2 = new.target === Cursor ? this : Object.create(Cursor.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry6.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry6.unregister(rsc2);
    rscTableRemove(handleTable6, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['20'](handleTable6[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let cstMethodCursorNode;

Object.defineProperty(Cursor.prototype, "node", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorNode(handle0);
  let variant6;
  switch (dataView(memory0).getUint8(ret + 0, true)) {
    case 0: {
      var handle3 = dataView(memory0).getInt32(ret + 4, true);
      var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
      Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
      finalizationRegistry4.register(rsc2, handle3, rsc2);
      Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
        finalizationRegistry4.unregister(rsc2);
        rscTableRemove(handleTable4, handle3);
        rsc2[symbolDispose] = emptyFunc;
        rsc2[symbolRscHandle] = undefined;
        exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc2;
      break;
    }
    case 1: {
      var handle5 = dataView(memory0).getInt32(ret + 4, true);
      var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
      Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
      finalizationRegistry5.register(rsc4, handle5, rsc4);
      Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
        finalizationRegistry5.unregister(rsc4);
        rscTableRemove(handleTable5, handle5);
        rsc4[symbolDispose] = emptyFunc;
        rsc4[symbolRscHandle] = undefined;
        exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc4;
      break;
    }
  }
  return variant6;
}});
let cstMethodCursorLabel;

Object.defineProperty(Cursor.prototype, "label", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorLabel(handle0);
  return edgeLabelCABI[ret];
}});
let cstMethodCursorTextOffset;

Object.defineProperty(Cursor.prototype, "textOffset", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorTextOffset(handle0);
  return {
    utf8: dataView(memory0).getInt32(ret + 0, true) >>> 0,
    utf16: dataView(memory0).getInt32(ret + 4, true) >>> 0,
    line: dataView(memory0).getInt32(ret + 8, true) >>> 0,
    column: dataView(memory0).getInt32(ret + 12, true) >>> 0,
  };
}});
let cstMethodCursorTextRange;

Object.defineProperty(Cursor.prototype, "textRange", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorTextRange(handle0);
  return {
    start: {
      utf8: dataView(memory0).getInt32(ret + 0, true) >>> 0,
      utf16: dataView(memory0).getInt32(ret + 4, true) >>> 0,
      line: dataView(memory0).getInt32(ret + 8, true) >>> 0,
      column: dataView(memory0).getInt32(ret + 12, true) >>> 0,
    },
    end: {
      utf8: dataView(memory0).getInt32(ret + 16, true) >>> 0,
      utf16: dataView(memory0).getInt32(ret + 20, true) >>> 0,
      line: dataView(memory0).getInt32(ret + 24, true) >>> 0,
      column: dataView(memory0).getInt32(ret + 28, true) >>> 0,
    },
  };
}});
let cstMethodCursorDepth;

Object.defineProperty(Cursor.prototype, "depth", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorDepth(handle0);
  return ret >>> 0;
}});
let cstMethodCursorChildren;

Cursor.prototype.children = function children() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorChildren(handle0);
  var len7 = dataView(memory0).getInt32(ret + 4, true);
  var base7 = dataView(memory0).getInt32(ret + 0, true);
  var result7 = [];
  for (let i = 0; i < len7; i++) {
    const base = base7 + i * 12;
    let variant6;
    switch (dataView(memory0).getUint8(base + 4, true)) {
      case 0: {
        var handle3 = dataView(memory0).getInt32(base + 8, true);
        var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
        Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
        finalizationRegistry4.register(rsc2, handle3, rsc2);
        Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
          finalizationRegistry4.unregister(rsc2);
          rscTableRemove(handleTable4, handle3);
          rsc2[symbolDispose] = emptyFunc;
          rsc2[symbolRscHandle] = undefined;
          exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc2;
        break;
      }
      case 1: {
        var handle5 = dataView(memory0).getInt32(base + 8, true);
        var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
        Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
        finalizationRegistry5.register(rsc4, handle5, rsc4);
        Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
          finalizationRegistry5.unregister(rsc4);
          rscTableRemove(handleTable5, handle5);
          rsc4[symbolDispose] = emptyFunc;
          rsc4[symbolRscHandle] = undefined;
          exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc4;
        break;
      }
    }
    result7.push({
      label: edgeLabelCABI[dataView(memory0).getUint8(base + 0, true)],
      node: variant6,
    });
  }
  const retVal = result7;
  postReturn0(ret);
  return retVal;
};
let cstMethodCursorDescendants;

Cursor.prototype.descendants = function descendants() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorDescendants(handle0);
  var handle3 = ret;
  var rsc2 = new.target === CursorIterator ? this : Object.create(CursorIterator.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry7.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry7.unregister(rsc2);
    rscTableRemove(handleTable7, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['21'](handleTable7[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let cstMethodCursorRemainingNodes;

Cursor.prototype.remainingNodes = function remainingNodes() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorRemainingNodes(handle0);
  var handle3 = ret;
  var rsc2 = new.target === CursorIterator ? this : Object.create(CursorIterator.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry7.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry7.unregister(rsc2);
    rscTableRemove(handleTable7, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['21'](handleTable7[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
const handleTable8 = [T_FLAG, 0];
const finalizationRegistry8 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable8, handle);
  exports0['22'](rep);
});

handleTables[8] = handleTable8;
let cstMethodCursorAncestors;

Cursor.prototype.ancestors = function ancestors() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorAncestors(handle0);
  var handle3 = ret;
  var rsc2 = new.target === AncestorsIterator ? this : Object.create(AncestorsIterator.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry8.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry8.unregister(rsc2);
    rscTableRemove(handleTable8, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['22'](handleTable8[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let cstMethodCursorGoToNext;

Cursor.prototype.goToNext = function goToNext() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNext(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNextNonDescendant;

Cursor.prototype.goToNextNonDescendant = function goToNextNonDescendant() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNextNonDescendant(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToPrevious;

Cursor.prototype.goToPrevious = function goToPrevious() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToPrevious(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToParent;

Cursor.prototype.goToParent = function goToParent() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToParent(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToFirstChild;

Cursor.prototype.goToFirstChild = function goToFirstChild() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToFirstChild(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToLastChild;

Cursor.prototype.goToLastChild = function goToLastChild() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToLastChild(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNthChild;

Cursor.prototype.goToNthChild = function goToNthChild(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNthChild(handle0, toUint32(arg1));
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNextSibling;

Cursor.prototype.goToNextSibling = function goToNextSibling() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNextSibling(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToPreviousSibling;

Cursor.prototype.goToPreviousSibling = function goToPreviousSibling() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToPreviousSibling(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNextTerminal;

Cursor.prototype.goToNextTerminal = function goToNextTerminal() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNextTerminal(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNextTerminalWithKind;

Cursor.prototype.goToNextTerminalWithKind = function goToNextTerminalWithKind(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNextTerminalWithKind(handle0, terminalKindCABI[arg1]);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNextTerminalWithKinds;

Cursor.prototype.goToNextTerminalWithKinds = function goToNextTerminalWithKinds(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var vec2 = arg1;
  var len2 = vec2.length;
  var result2 = realloc1(0, 0, 2, len2 * 2);
  for (let i = 0; i < vec2.length; i++) {
    const e = vec2[i];
    const base = result2 + i * 2;dataView(memory0).setInt16(base + 0, terminalKindCABI[e], true);
  }
  const ret = cstMethodCursorGoToNextTerminalWithKinds(handle0, result2, len2);
  var bool3 = ret;
  return !!bool3;
};
let cstMethodCursorGoToNextNonterminal;

Cursor.prototype.goToNextNonterminal = function goToNextNonterminal() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNextNonterminal(handle0);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNextNonterminalWithKind;

Cursor.prototype.goToNextNonterminalWithKind = function goToNextNonterminalWithKind(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorGoToNextNonterminalWithKind(handle0, nonterminalKindCABI[arg1]);
  var bool2 = ret;
  return !!bool2;
};
let cstMethodCursorGoToNextNonterminalWithKinds;

Cursor.prototype.goToNextNonterminalWithKinds = function goToNextNonterminalWithKinds(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var vec2 = arg1;
  var len2 = vec2.length;
  var result2 = realloc1(0, 0, 1, len2 * 1);
  for (let i = 0; i < vec2.length; i++) {
    const e = vec2[i];
    const base = result2 + i * 1;dataView(memory0).setInt8(base + 0, nonterminalKindCABI[e], true);
  }
  const ret = cstMethodCursorGoToNextNonterminalWithKinds(handle0, result2, len2);
  var bool3 = ret;
  return !!bool3;
};
const handleTable9 = [T_FLAG, 0];
const finalizationRegistry9 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable9, handle);
  exports0['23'](rep);
});

handleTables[9] = handleTable9;
const handleTable10 = [T_FLAG, 0];
const finalizationRegistry10 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable10, handle);
  exports0['24'](rep);
});

handleTables[10] = handleTable10;
let cstMethodCursorQuery;

Cursor.prototype.query = function query(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable6[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle0 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var vec4 = arg1;
  var len4 = vec4.length;
  var result4 = realloc1(0, 0, 4, len4 * 4);
  for (let i = 0; i < vec4.length; i++) {
    const e = vec4[i];
    const base = result4 + i * 4;var handle3 = e[symbolRscHandle];
    if (!handle3 || (handleTable9[(handle3 << 1) + 1] & T_FLAG) === 0) {
      throw new TypeError('Resource error: Not a valid "Query" resource.');
    }
    var handle2 = handleTable9[(handle3 << 1) + 1] & ~T_FLAG;
    dataView(memory0).setInt32(base + 0, handle2, true);
  }
  const ret = cstMethodCursorQuery(handle0, result4, len4);
  var handle6 = ret;
  var rsc5 = new.target === QueryMatchIterator ? this : Object.create(QueryMatchIterator.prototype);
  Object.defineProperty(rsc5, symbolRscHandle, { writable: true, value: handle6});
  finalizationRegistry10.register(rsc5, handle6, rsc5);
  Object.defineProperty(rsc5, symbolDispose, { writable: true, value: function () {
    finalizationRegistry10.unregister(rsc5);
    rscTableRemove(handleTable10, handle6);
    rsc5[symbolDispose] = emptyFunc;
    rsc5[symbolRscHandle] = undefined;
    exports0['24'](handleTable10[(handle6 << 1) + 1] & ~T_FLAG);
  }});
  return rsc5;
};
let cstMethodCursorIteratorNext;

class CursorIterator{
  constructor () {
    throw new Error('"CursorIterator" resource does not define a constructor');
  }
}

CursorIterator.prototype[Symbol.iterator] = function () {
  return {
    next: () => {
      const value = this.next();
      return { done: value == undefined, value };
    }
  }
}


CursorIterator.prototype.next = function next() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable7[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "CursorIterator" resource.');
  }
  var handle0 = handleTable7[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodCursorIteratorNext(handle0);
  let variant7;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    let variant6;
    switch (dataView(memory0).getUint8(ret + 8, true)) {
      case 0: {
        var handle3 = dataView(memory0).getInt32(ret + 12, true);
        var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
        Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
        finalizationRegistry4.register(rsc2, handle3, rsc2);
        Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
          finalizationRegistry4.unregister(rsc2);
          rscTableRemove(handleTable4, handle3);
          rsc2[symbolDispose] = emptyFunc;
          rsc2[symbolRscHandle] = undefined;
          exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc2;
        break;
      }
      case 1: {
        var handle5 = dataView(memory0).getInt32(ret + 12, true);
        var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
        Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
        finalizationRegistry5.register(rsc4, handle5, rsc4);
        Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
          finalizationRegistry5.unregister(rsc4);
          rscTableRemove(handleTable5, handle5);
          rsc4[symbolDispose] = emptyFunc;
          rsc4[symbolRscHandle] = undefined;
          exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc4;
        break;
      }
    }
    variant7 = {
      label: edgeLabelCABI[dataView(memory0).getUint8(ret + 4, true)],
      node: variant6,
    };
  } else {
    variant7 = undefined;
  }
  return variant7;
};
let cstMethodAncestorsIteratorNext;

class AncestorsIterator{
  constructor () {
    throw new Error('"AncestorsIterator" resource does not define a constructor');
  }
}

AncestorsIterator.prototype[Symbol.iterator] = function () {
  return {
    next: () => {
      const value = this.next();
      return { done: value == undefined, value };
    }
  }
}


AncestorsIterator.prototype.next = function next() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable8[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "AncestorsIterator" resource.');
  }
  var handle0 = handleTable8[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodAncestorsIteratorNext(handle0);
  let variant4;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var handle3 = dataView(memory0).getInt32(ret + 4, true);
    var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
    Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
    finalizationRegistry4.register(rsc2, handle3, rsc2);
    Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
      finalizationRegistry4.unregister(rsc2);
      rscTableRemove(handleTable4, handle3);
      rsc2[symbolDispose] = emptyFunc;
      rsc2[symbolRscHandle] = undefined;
      exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
    }});
    variant4 = rsc2;
  } else {
    variant4 = undefined;
  }
  return variant4;
};
let cstStaticQueryCreate;

class Query{
  constructor () {
    throw new Error('"Query" resource does not define a constructor');
  }
}

Query.create = function create(arg0) {
  var ptr0 = utf8Encode(arg0, realloc1, memory0);
  var len0 = utf8EncodedLen;
  const ret = cstStaticQueryCreate(ptr0, len0);
  let variant4;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr3 = dataView(memory0).getInt32(ret + 4, true);
    var len3 = dataView(memory0).getInt32(ret + 8, true);
    var result3 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    variant4= {
      tag: 'err',
      val: {
        message: result3,
        textRange: {
          start: {
            utf8: dataView(memory0).getInt32(ret + 12, true) >>> 0,
            utf16: dataView(memory0).getInt32(ret + 16, true) >>> 0,
            line: dataView(memory0).getInt32(ret + 20, true) >>> 0,
            column: dataView(memory0).getInt32(ret + 24, true) >>> 0,
          },
          end: {
            utf8: dataView(memory0).getInt32(ret + 28, true) >>> 0,
            utf16: dataView(memory0).getInt32(ret + 32, true) >>> 0,
            line: dataView(memory0).getInt32(ret + 36, true) >>> 0,
            column: dataView(memory0).getInt32(ret + 40, true) >>> 0,
          },
        },
      }
    };
  } else {
    var handle2 = dataView(memory0).getInt32(ret + 4, true);
    var rsc1 = new.target === Query ? this : Object.create(Query.prototype);
    Object.defineProperty(rsc1, symbolRscHandle, { writable: true, value: handle2});
    finalizationRegistry9.register(rsc1, handle2, rsc1);
    Object.defineProperty(rsc1, symbolDispose, { writable: true, value: function () {
      finalizationRegistry9.unregister(rsc1);
      rscTableRemove(handleTable9, handle2);
      rsc1[symbolDispose] = emptyFunc;
      rsc1[symbolRscHandle] = undefined;
      exports0['23'](handleTable9[(handle2 << 1) + 1] & ~T_FLAG);
    }});
    variant4= {
      tag: 'ok',
      val: rsc1
    };
  }
  const retVal = variant4;
  postReturn2(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
let cstMethodQueryMatchIteratorNext;

class QueryMatchIterator{
  constructor () {
    throw new Error('"QueryMatchIterator" resource does not define a constructor');
  }
}

QueryMatchIterator.prototype[Symbol.iterator] = function () {
  return {
    next: () => {
      const value = this.next();
      return { done: value == undefined, value };
    }
  }
}


QueryMatchIterator.prototype.next = function next() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable10[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "QueryMatchIterator" resource.');
  }
  var handle0 = handleTable10[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = cstMethodQueryMatchIteratorNext(handle0);
  let variant9;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var handle3 = dataView(memory0).getInt32(ret + 8, true);
    var rsc2 = new.target === Cursor ? this : Object.create(Cursor.prototype);
    Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
    finalizationRegistry6.register(rsc2, handle3, rsc2);
    Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
      finalizationRegistry6.unregister(rsc2);
      rscTableRemove(handleTable6, handle3);
      rsc2[symbolDispose] = emptyFunc;
      rsc2[symbolRscHandle] = undefined;
      exports0['20'](handleTable6[(handle3 << 1) + 1] & ~T_FLAG);
    }});
    var len8 = dataView(memory0).getInt32(ret + 16, true);
    var base8 = dataView(memory0).getInt32(ret + 12, true);
    var result8 = [];
    for (let i = 0; i < len8; i++) {
      const base = base8 + i * 16;
      var ptr4 = dataView(memory0).getInt32(base + 0, true);
      var len4 = dataView(memory0).getInt32(base + 4, true);
      var result4 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr4, len4));
      var len7 = dataView(memory0).getInt32(base + 12, true);
      var base7 = dataView(memory0).getInt32(base + 8, true);
      var result7 = [];
      for (let i = 0; i < len7; i++) {
        const base = base7 + i * 4;
        var handle6 = dataView(memory0).getInt32(base + 0, true);
        var rsc5 = new.target === Cursor ? this : Object.create(Cursor.prototype);
        Object.defineProperty(rsc5, symbolRscHandle, { writable: true, value: handle6});
        finalizationRegistry6.register(rsc5, handle6, rsc5);
        Object.defineProperty(rsc5, symbolDispose, { writable: true, value: function () {
          finalizationRegistry6.unregister(rsc5);
          rscTableRemove(handleTable6, handle6);
          rsc5[symbolDispose] = emptyFunc;
          rsc5[symbolRscHandle] = undefined;
          exports0['20'](handleTable6[(handle6 << 1) + 1] & ~T_FLAG);
        }});
        result7.push(rsc5);
      }
      result8.push([result4, result7]);
    }
    variant9 = {
      queryIndex: dataView(memory0).getInt32(ret + 4, true) >>> 0,
      root: rsc2,
      captures: result8.reduce((acc, val) => { acc[val[0]] = val[1]; return acc; }, {}),
    };
  } else {
    variant9 = undefined;
  }
  const retVal = variant9;
  postReturn3(ret);
  return retVal;
};
var nonterminalKind = {};
nonterminalKind['AbicoderPragma'] = 'AbicoderPragma';
nonterminalKind['AdditiveExpression'] = 'AdditiveExpression';
nonterminalKind['AddressType'] = 'AddressType';
nonterminalKind['AndExpression'] = 'AndExpression';
nonterminalKind['ArgumentsDeclaration'] = 'ArgumentsDeclaration';
nonterminalKind['ArrayExpression'] = 'ArrayExpression';
nonterminalKind['ArrayTypeName'] = 'ArrayTypeName';
nonterminalKind['ArrayValues'] = 'ArrayValues';
nonterminalKind['AssemblyFlags'] = 'AssemblyFlags';
nonterminalKind['AssemblyFlagsDeclaration'] = 'AssemblyFlagsDeclaration';
nonterminalKind['AssemblyStatement'] = 'AssemblyStatement';
nonterminalKind['AssignmentExpression'] = 'AssignmentExpression';
nonterminalKind['BitwiseAndExpression'] = 'BitwiseAndExpression';
nonterminalKind['BitwiseOrExpression'] = 'BitwiseOrExpression';
nonterminalKind['BitwiseXorExpression'] = 'BitwiseXorExpression';
nonterminalKind['Block'] = 'Block';
nonterminalKind['BreakStatement'] = 'BreakStatement';
nonterminalKind['CallOptions'] = 'CallOptions';
nonterminalKind['CallOptionsExpression'] = 'CallOptionsExpression';
nonterminalKind['CatchClause'] = 'CatchClause';
nonterminalKind['CatchClauseError'] = 'CatchClauseError';
nonterminalKind['CatchClauses'] = 'CatchClauses';
nonterminalKind['ConditionalExpression'] = 'ConditionalExpression';
nonterminalKind['ConstantDefinition'] = 'ConstantDefinition';
nonterminalKind['ConstructorAttribute'] = 'ConstructorAttribute';
nonterminalKind['ConstructorAttributes'] = 'ConstructorAttributes';
nonterminalKind['ConstructorDefinition'] = 'ConstructorDefinition';
nonterminalKind['ContinueStatement'] = 'ContinueStatement';
nonterminalKind['ContractDefinition'] = 'ContractDefinition';
nonterminalKind['ContractMember'] = 'ContractMember';
nonterminalKind['ContractMembers'] = 'ContractMembers';
nonterminalKind['ContractSpecifier'] = 'ContractSpecifier';
nonterminalKind['ContractSpecifiers'] = 'ContractSpecifiers';
nonterminalKind['DecimalNumberExpression'] = 'DecimalNumberExpression';
nonterminalKind['DoWhileStatement'] = 'DoWhileStatement';
nonterminalKind['ElementaryType'] = 'ElementaryType';
nonterminalKind['ElseBranch'] = 'ElseBranch';
nonterminalKind['EmitStatement'] = 'EmitStatement';
nonterminalKind['EnumDefinition'] = 'EnumDefinition';
nonterminalKind['EnumMembers'] = 'EnumMembers';
nonterminalKind['EqualityExpression'] = 'EqualityExpression';
nonterminalKind['ErrorDefinition'] = 'ErrorDefinition';
nonterminalKind['ErrorParameter'] = 'ErrorParameter';
nonterminalKind['ErrorParameters'] = 'ErrorParameters';
nonterminalKind['ErrorParametersDeclaration'] = 'ErrorParametersDeclaration';
nonterminalKind['EventDefinition'] = 'EventDefinition';
nonterminalKind['EventParameter'] = 'EventParameter';
nonterminalKind['EventParameters'] = 'EventParameters';
nonterminalKind['EventParametersDeclaration'] = 'EventParametersDeclaration';
nonterminalKind['ExperimentalFeature'] = 'ExperimentalFeature';
nonterminalKind['ExperimentalPragma'] = 'ExperimentalPragma';
nonterminalKind['ExponentiationExpression'] = 'ExponentiationExpression';
nonterminalKind['Expression'] = 'Expression';
nonterminalKind['ExpressionStatement'] = 'ExpressionStatement';
nonterminalKind['FallbackFunctionAttribute'] = 'FallbackFunctionAttribute';
nonterminalKind['FallbackFunctionAttributes'] = 'FallbackFunctionAttributes';
nonterminalKind['FallbackFunctionDefinition'] = 'FallbackFunctionDefinition';
nonterminalKind['ForStatement'] = 'ForStatement';
nonterminalKind['ForStatementCondition'] = 'ForStatementCondition';
nonterminalKind['ForStatementInitialization'] = 'ForStatementInitialization';
nonterminalKind['FunctionAttribute'] = 'FunctionAttribute';
nonterminalKind['FunctionAttributes'] = 'FunctionAttributes';
nonterminalKind['FunctionBody'] = 'FunctionBody';
nonterminalKind['FunctionCallExpression'] = 'FunctionCallExpression';
nonterminalKind['FunctionDefinition'] = 'FunctionDefinition';
nonterminalKind['FunctionName'] = 'FunctionName';
nonterminalKind['FunctionType'] = 'FunctionType';
nonterminalKind['FunctionTypeAttribute'] = 'FunctionTypeAttribute';
nonterminalKind['FunctionTypeAttributes'] = 'FunctionTypeAttributes';
nonterminalKind['HexNumberExpression'] = 'HexNumberExpression';
nonterminalKind['HexStringLiteral'] = 'HexStringLiteral';
nonterminalKind['HexStringLiterals'] = 'HexStringLiterals';
nonterminalKind['IdentifierPath'] = 'IdentifierPath';
nonterminalKind['IfStatement'] = 'IfStatement';
nonterminalKind['ImportAlias'] = 'ImportAlias';
nonterminalKind['ImportClause'] = 'ImportClause';
nonterminalKind['ImportDeconstruction'] = 'ImportDeconstruction';
nonterminalKind['ImportDeconstructionSymbol'] = 'ImportDeconstructionSymbol';
nonterminalKind['ImportDeconstructionSymbols'] = 'ImportDeconstructionSymbols';
nonterminalKind['ImportDirective'] = 'ImportDirective';
nonterminalKind['IndexAccessEnd'] = 'IndexAccessEnd';
nonterminalKind['IndexAccessExpression'] = 'IndexAccessExpression';
nonterminalKind['InequalityExpression'] = 'InequalityExpression';
nonterminalKind['InheritanceSpecifier'] = 'InheritanceSpecifier';
nonterminalKind['InheritanceType'] = 'InheritanceType';
nonterminalKind['InheritanceTypes'] = 'InheritanceTypes';
nonterminalKind['InterfaceDefinition'] = 'InterfaceDefinition';
nonterminalKind['InterfaceMembers'] = 'InterfaceMembers';
nonterminalKind['LibraryDefinition'] = 'LibraryDefinition';
nonterminalKind['LibraryMembers'] = 'LibraryMembers';
nonterminalKind['MappingKey'] = 'MappingKey';
nonterminalKind['MappingKeyType'] = 'MappingKeyType';
nonterminalKind['MappingType'] = 'MappingType';
nonterminalKind['MappingValue'] = 'MappingValue';
nonterminalKind['MemberAccessExpression'] = 'MemberAccessExpression';
nonterminalKind['ModifierAttribute'] = 'ModifierAttribute';
nonterminalKind['ModifierAttributes'] = 'ModifierAttributes';
nonterminalKind['ModifierDefinition'] = 'ModifierDefinition';
nonterminalKind['ModifierInvocation'] = 'ModifierInvocation';
nonterminalKind['MultiplicativeExpression'] = 'MultiplicativeExpression';
nonterminalKind['NamedArgument'] = 'NamedArgument';
nonterminalKind['NamedArgumentGroup'] = 'NamedArgumentGroup';
nonterminalKind['NamedArguments'] = 'NamedArguments';
nonterminalKind['NamedArgumentsDeclaration'] = 'NamedArgumentsDeclaration';
nonterminalKind['NamedImport'] = 'NamedImport';
nonterminalKind['NewExpression'] = 'NewExpression';
nonterminalKind['NumberUnit'] = 'NumberUnit';
nonterminalKind['OrExpression'] = 'OrExpression';
nonterminalKind['OverridePaths'] = 'OverridePaths';
nonterminalKind['OverridePathsDeclaration'] = 'OverridePathsDeclaration';
nonterminalKind['OverrideSpecifier'] = 'OverrideSpecifier';
nonterminalKind['Parameter'] = 'Parameter';
nonterminalKind['Parameters'] = 'Parameters';
nonterminalKind['ParametersDeclaration'] = 'ParametersDeclaration';
nonterminalKind['PathImport'] = 'PathImport';
nonterminalKind['PositionalArguments'] = 'PositionalArguments';
nonterminalKind['PositionalArgumentsDeclaration'] = 'PositionalArgumentsDeclaration';
nonterminalKind['PostfixExpression'] = 'PostfixExpression';
nonterminalKind['Pragma'] = 'Pragma';
nonterminalKind['PragmaDirective'] = 'PragmaDirective';
nonterminalKind['PrefixExpression'] = 'PrefixExpression';
nonterminalKind['ReceiveFunctionAttribute'] = 'ReceiveFunctionAttribute';
nonterminalKind['ReceiveFunctionAttributes'] = 'ReceiveFunctionAttributes';
nonterminalKind['ReceiveFunctionDefinition'] = 'ReceiveFunctionDefinition';
nonterminalKind['ReturnStatement'] = 'ReturnStatement';
nonterminalKind['ReturnsDeclaration'] = 'ReturnsDeclaration';
nonterminalKind['RevertStatement'] = 'RevertStatement';
nonterminalKind['ShiftExpression'] = 'ShiftExpression';
nonterminalKind['SimpleVersionLiteral'] = 'SimpleVersionLiteral';
nonterminalKind['SourceUnit'] = 'SourceUnit';
nonterminalKind['SourceUnitMember'] = 'SourceUnitMember';
nonterminalKind['SourceUnitMembers'] = 'SourceUnitMembers';
nonterminalKind['StateVariableAttribute'] = 'StateVariableAttribute';
nonterminalKind['StateVariableAttributes'] = 'StateVariableAttributes';
nonterminalKind['StateVariableDefinition'] = 'StateVariableDefinition';
nonterminalKind['StateVariableDefinitionValue'] = 'StateVariableDefinitionValue';
nonterminalKind['Statement'] = 'Statement';
nonterminalKind['Statements'] = 'Statements';
nonterminalKind['StorageLayoutSpecifier'] = 'StorageLayoutSpecifier';
nonterminalKind['StorageLocation'] = 'StorageLocation';
nonterminalKind['StringExpression'] = 'StringExpression';
nonterminalKind['StringLiteral'] = 'StringLiteral';
nonterminalKind['StringLiterals'] = 'StringLiterals';
nonterminalKind['StructDefinition'] = 'StructDefinition';
nonterminalKind['StructMember'] = 'StructMember';
nonterminalKind['StructMembers'] = 'StructMembers';
nonterminalKind['ThrowStatement'] = 'ThrowStatement';
nonterminalKind['TryStatement'] = 'TryStatement';
nonterminalKind['TupleDeconstructionElement'] = 'TupleDeconstructionElement';
nonterminalKind['TupleDeconstructionElements'] = 'TupleDeconstructionElements';
nonterminalKind['TupleDeconstructionStatement'] = 'TupleDeconstructionStatement';
nonterminalKind['TupleExpression'] = 'TupleExpression';
nonterminalKind['TupleMember'] = 'TupleMember';
nonterminalKind['TupleValue'] = 'TupleValue';
nonterminalKind['TupleValues'] = 'TupleValues';
nonterminalKind['TypeExpression'] = 'TypeExpression';
nonterminalKind['TypeName'] = 'TypeName';
nonterminalKind['TypedTupleMember'] = 'TypedTupleMember';
nonterminalKind['UncheckedBlock'] = 'UncheckedBlock';
nonterminalKind['UnicodeStringLiteral'] = 'UnicodeStringLiteral';
nonterminalKind['UnicodeStringLiterals'] = 'UnicodeStringLiterals';
nonterminalKind['UnnamedFunctionAttribute'] = 'UnnamedFunctionAttribute';
nonterminalKind['UnnamedFunctionAttributes'] = 'UnnamedFunctionAttributes';
nonterminalKind['UnnamedFunctionDefinition'] = 'UnnamedFunctionDefinition';
nonterminalKind['UntypedTupleMember'] = 'UntypedTupleMember';
nonterminalKind['UserDefinedValueTypeDefinition'] = 'UserDefinedValueTypeDefinition';
nonterminalKind['UsingAlias'] = 'UsingAlias';
nonterminalKind['UsingClause'] = 'UsingClause';
nonterminalKind['UsingDeconstruction'] = 'UsingDeconstruction';
nonterminalKind['UsingDeconstructionSymbol'] = 'UsingDeconstructionSymbol';
nonterminalKind['UsingDeconstructionSymbols'] = 'UsingDeconstructionSymbols';
nonterminalKind['UsingDirective'] = 'UsingDirective';
nonterminalKind['UsingOperator'] = 'UsingOperator';
nonterminalKind['UsingTarget'] = 'UsingTarget';
nonterminalKind['VariableDeclarationStatement'] = 'VariableDeclarationStatement';
nonterminalKind['VariableDeclarationType'] = 'VariableDeclarationType';
nonterminalKind['VariableDeclarationValue'] = 'VariableDeclarationValue';
nonterminalKind['VersionExpression'] = 'VersionExpression';
nonterminalKind['VersionExpressionSet'] = 'VersionExpressionSet';
nonterminalKind['VersionExpressionSets'] = 'VersionExpressionSets';
nonterminalKind['VersionLiteral'] = 'VersionLiteral';
nonterminalKind['VersionOperator'] = 'VersionOperator';
nonterminalKind['VersionPragma'] = 'VersionPragma';
nonterminalKind['VersionRange'] = 'VersionRange';
nonterminalKind['VersionTerm'] = 'VersionTerm';
nonterminalKind['WhileStatement'] = 'WhileStatement';
nonterminalKind['YulArguments'] = 'YulArguments';
nonterminalKind['YulAssignmentOperator'] = 'YulAssignmentOperator';
nonterminalKind['YulBlock'] = 'YulBlock';
nonterminalKind['YulBreakStatement'] = 'YulBreakStatement';
nonterminalKind['YulColonAndEqual'] = 'YulColonAndEqual';
nonterminalKind['YulContinueStatement'] = 'YulContinueStatement';
nonterminalKind['YulDefaultCase'] = 'YulDefaultCase';
nonterminalKind['YulEqualAndColon'] = 'YulEqualAndColon';
nonterminalKind['YulExpression'] = 'YulExpression';
nonterminalKind['YulForStatement'] = 'YulForStatement';
nonterminalKind['YulFunctionCallExpression'] = 'YulFunctionCallExpression';
nonterminalKind['YulFunctionDefinition'] = 'YulFunctionDefinition';
nonterminalKind['YulIfStatement'] = 'YulIfStatement';
nonterminalKind['YulLabel'] = 'YulLabel';
nonterminalKind['YulLeaveStatement'] = 'YulLeaveStatement';
nonterminalKind['YulLiteral'] = 'YulLiteral';
nonterminalKind['YulParameters'] = 'YulParameters';
nonterminalKind['YulParametersDeclaration'] = 'YulParametersDeclaration';
nonterminalKind['YulPath'] = 'YulPath';
nonterminalKind['YulPaths'] = 'YulPaths';
nonterminalKind['YulReturnsDeclaration'] = 'YulReturnsDeclaration';
nonterminalKind['YulStackAssignmentOperator'] = 'YulStackAssignmentOperator';
nonterminalKind['YulStackAssignmentStatement'] = 'YulStackAssignmentStatement';
nonterminalKind['YulStatement'] = 'YulStatement';
nonterminalKind['YulStatements'] = 'YulStatements';
nonterminalKind['YulSwitchCase'] = 'YulSwitchCase';
nonterminalKind['YulSwitchCases'] = 'YulSwitchCases';
nonterminalKind['YulSwitchStatement'] = 'YulSwitchStatement';
nonterminalKind['YulValueCase'] = 'YulValueCase';
nonterminalKind['YulVariableAssignmentStatement'] = 'YulVariableAssignmentStatement';
nonterminalKind['YulVariableDeclarationStatement'] = 'YulVariableDeclarationStatement';
nonterminalKind['YulVariableDeclarationValue'] = 'YulVariableDeclarationValue';
nonterminalKind['YulVariableNames'] = 'YulVariableNames';

var nonterminalKindCABI = {};
nonterminalKindCABI[nonterminalKindCABI['AbicoderPragma'] = 0] = 'AbicoderPragma';
nonterminalKindCABI[nonterminalKindCABI['AdditiveExpression'] = 1] = 'AdditiveExpression';
nonterminalKindCABI[nonterminalKindCABI['AddressType'] = 2] = 'AddressType';
nonterminalKindCABI[nonterminalKindCABI['AndExpression'] = 3] = 'AndExpression';
nonterminalKindCABI[nonterminalKindCABI['ArgumentsDeclaration'] = 4] = 'ArgumentsDeclaration';
nonterminalKindCABI[nonterminalKindCABI['ArrayExpression'] = 5] = 'ArrayExpression';
nonterminalKindCABI[nonterminalKindCABI['ArrayTypeName'] = 6] = 'ArrayTypeName';
nonterminalKindCABI[nonterminalKindCABI['ArrayValues'] = 7] = 'ArrayValues';
nonterminalKindCABI[nonterminalKindCABI['AssemblyFlags'] = 8] = 'AssemblyFlags';
nonterminalKindCABI[nonterminalKindCABI['AssemblyFlagsDeclaration'] = 9] = 'AssemblyFlagsDeclaration';
nonterminalKindCABI[nonterminalKindCABI['AssemblyStatement'] = 10] = 'AssemblyStatement';
nonterminalKindCABI[nonterminalKindCABI['AssignmentExpression'] = 11] = 'AssignmentExpression';
nonterminalKindCABI[nonterminalKindCABI['BitwiseAndExpression'] = 12] = 'BitwiseAndExpression';
nonterminalKindCABI[nonterminalKindCABI['BitwiseOrExpression'] = 13] = 'BitwiseOrExpression';
nonterminalKindCABI[nonterminalKindCABI['BitwiseXorExpression'] = 14] = 'BitwiseXorExpression';
nonterminalKindCABI[nonterminalKindCABI['Block'] = 15] = 'Block';
nonterminalKindCABI[nonterminalKindCABI['BreakStatement'] = 16] = 'BreakStatement';
nonterminalKindCABI[nonterminalKindCABI['CallOptions'] = 17] = 'CallOptions';
nonterminalKindCABI[nonterminalKindCABI['CallOptionsExpression'] = 18] = 'CallOptionsExpression';
nonterminalKindCABI[nonterminalKindCABI['CatchClause'] = 19] = 'CatchClause';
nonterminalKindCABI[nonterminalKindCABI['CatchClauseError'] = 20] = 'CatchClauseError';
nonterminalKindCABI[nonterminalKindCABI['CatchClauses'] = 21] = 'CatchClauses';
nonterminalKindCABI[nonterminalKindCABI['ConditionalExpression'] = 22] = 'ConditionalExpression';
nonterminalKindCABI[nonterminalKindCABI['ConstantDefinition'] = 23] = 'ConstantDefinition';
nonterminalKindCABI[nonterminalKindCABI['ConstructorAttribute'] = 24] = 'ConstructorAttribute';
nonterminalKindCABI[nonterminalKindCABI['ConstructorAttributes'] = 25] = 'ConstructorAttributes';
nonterminalKindCABI[nonterminalKindCABI['ConstructorDefinition'] = 26] = 'ConstructorDefinition';
nonterminalKindCABI[nonterminalKindCABI['ContinueStatement'] = 27] = 'ContinueStatement';
nonterminalKindCABI[nonterminalKindCABI['ContractDefinition'] = 28] = 'ContractDefinition';
nonterminalKindCABI[nonterminalKindCABI['ContractMember'] = 29] = 'ContractMember';
nonterminalKindCABI[nonterminalKindCABI['ContractMembers'] = 30] = 'ContractMembers';
nonterminalKindCABI[nonterminalKindCABI['ContractSpecifier'] = 31] = 'ContractSpecifier';
nonterminalKindCABI[nonterminalKindCABI['ContractSpecifiers'] = 32] = 'ContractSpecifiers';
nonterminalKindCABI[nonterminalKindCABI['DecimalNumberExpression'] = 33] = 'DecimalNumberExpression';
nonterminalKindCABI[nonterminalKindCABI['DoWhileStatement'] = 34] = 'DoWhileStatement';
nonterminalKindCABI[nonterminalKindCABI['ElementaryType'] = 35] = 'ElementaryType';
nonterminalKindCABI[nonterminalKindCABI['ElseBranch'] = 36] = 'ElseBranch';
nonterminalKindCABI[nonterminalKindCABI['EmitStatement'] = 37] = 'EmitStatement';
nonterminalKindCABI[nonterminalKindCABI['EnumDefinition'] = 38] = 'EnumDefinition';
nonterminalKindCABI[nonterminalKindCABI['EnumMembers'] = 39] = 'EnumMembers';
nonterminalKindCABI[nonterminalKindCABI['EqualityExpression'] = 40] = 'EqualityExpression';
nonterminalKindCABI[nonterminalKindCABI['ErrorDefinition'] = 41] = 'ErrorDefinition';
nonterminalKindCABI[nonterminalKindCABI['ErrorParameter'] = 42] = 'ErrorParameter';
nonterminalKindCABI[nonterminalKindCABI['ErrorParameters'] = 43] = 'ErrorParameters';
nonterminalKindCABI[nonterminalKindCABI['ErrorParametersDeclaration'] = 44] = 'ErrorParametersDeclaration';
nonterminalKindCABI[nonterminalKindCABI['EventDefinition'] = 45] = 'EventDefinition';
nonterminalKindCABI[nonterminalKindCABI['EventParameter'] = 46] = 'EventParameter';
nonterminalKindCABI[nonterminalKindCABI['EventParameters'] = 47] = 'EventParameters';
nonterminalKindCABI[nonterminalKindCABI['EventParametersDeclaration'] = 48] = 'EventParametersDeclaration';
nonterminalKindCABI[nonterminalKindCABI['ExperimentalFeature'] = 49] = 'ExperimentalFeature';
nonterminalKindCABI[nonterminalKindCABI['ExperimentalPragma'] = 50] = 'ExperimentalPragma';
nonterminalKindCABI[nonterminalKindCABI['ExponentiationExpression'] = 51] = 'ExponentiationExpression';
nonterminalKindCABI[nonterminalKindCABI['Expression'] = 52] = 'Expression';
nonterminalKindCABI[nonterminalKindCABI['ExpressionStatement'] = 53] = 'ExpressionStatement';
nonterminalKindCABI[nonterminalKindCABI['FallbackFunctionAttribute'] = 54] = 'FallbackFunctionAttribute';
nonterminalKindCABI[nonterminalKindCABI['FallbackFunctionAttributes'] = 55] = 'FallbackFunctionAttributes';
nonterminalKindCABI[nonterminalKindCABI['FallbackFunctionDefinition'] = 56] = 'FallbackFunctionDefinition';
nonterminalKindCABI[nonterminalKindCABI['ForStatement'] = 57] = 'ForStatement';
nonterminalKindCABI[nonterminalKindCABI['ForStatementCondition'] = 58] = 'ForStatementCondition';
nonterminalKindCABI[nonterminalKindCABI['ForStatementInitialization'] = 59] = 'ForStatementInitialization';
nonterminalKindCABI[nonterminalKindCABI['FunctionAttribute'] = 60] = 'FunctionAttribute';
nonterminalKindCABI[nonterminalKindCABI['FunctionAttributes'] = 61] = 'FunctionAttributes';
nonterminalKindCABI[nonterminalKindCABI['FunctionBody'] = 62] = 'FunctionBody';
nonterminalKindCABI[nonterminalKindCABI['FunctionCallExpression'] = 63] = 'FunctionCallExpression';
nonterminalKindCABI[nonterminalKindCABI['FunctionDefinition'] = 64] = 'FunctionDefinition';
nonterminalKindCABI[nonterminalKindCABI['FunctionName'] = 65] = 'FunctionName';
nonterminalKindCABI[nonterminalKindCABI['FunctionType'] = 66] = 'FunctionType';
nonterminalKindCABI[nonterminalKindCABI['FunctionTypeAttribute'] = 67] = 'FunctionTypeAttribute';
nonterminalKindCABI[nonterminalKindCABI['FunctionTypeAttributes'] = 68] = 'FunctionTypeAttributes';
nonterminalKindCABI[nonterminalKindCABI['HexNumberExpression'] = 69] = 'HexNumberExpression';
nonterminalKindCABI[nonterminalKindCABI['HexStringLiteral'] = 70] = 'HexStringLiteral';
nonterminalKindCABI[nonterminalKindCABI['HexStringLiterals'] = 71] = 'HexStringLiterals';
nonterminalKindCABI[nonterminalKindCABI['IdentifierPath'] = 72] = 'IdentifierPath';
nonterminalKindCABI[nonterminalKindCABI['IfStatement'] = 73] = 'IfStatement';
nonterminalKindCABI[nonterminalKindCABI['ImportAlias'] = 74] = 'ImportAlias';
nonterminalKindCABI[nonterminalKindCABI['ImportClause'] = 75] = 'ImportClause';
nonterminalKindCABI[nonterminalKindCABI['ImportDeconstruction'] = 76] = 'ImportDeconstruction';
nonterminalKindCABI[nonterminalKindCABI['ImportDeconstructionSymbol'] = 77] = 'ImportDeconstructionSymbol';
nonterminalKindCABI[nonterminalKindCABI['ImportDeconstructionSymbols'] = 78] = 'ImportDeconstructionSymbols';
nonterminalKindCABI[nonterminalKindCABI['ImportDirective'] = 79] = 'ImportDirective';
nonterminalKindCABI[nonterminalKindCABI['IndexAccessEnd'] = 80] = 'IndexAccessEnd';
nonterminalKindCABI[nonterminalKindCABI['IndexAccessExpression'] = 81] = 'IndexAccessExpression';
nonterminalKindCABI[nonterminalKindCABI['InequalityExpression'] = 82] = 'InequalityExpression';
nonterminalKindCABI[nonterminalKindCABI['InheritanceSpecifier'] = 83] = 'InheritanceSpecifier';
nonterminalKindCABI[nonterminalKindCABI['InheritanceType'] = 84] = 'InheritanceType';
nonterminalKindCABI[nonterminalKindCABI['InheritanceTypes'] = 85] = 'InheritanceTypes';
nonterminalKindCABI[nonterminalKindCABI['InterfaceDefinition'] = 86] = 'InterfaceDefinition';
nonterminalKindCABI[nonterminalKindCABI['InterfaceMembers'] = 87] = 'InterfaceMembers';
nonterminalKindCABI[nonterminalKindCABI['LibraryDefinition'] = 88] = 'LibraryDefinition';
nonterminalKindCABI[nonterminalKindCABI['LibraryMembers'] = 89] = 'LibraryMembers';
nonterminalKindCABI[nonterminalKindCABI['MappingKey'] = 90] = 'MappingKey';
nonterminalKindCABI[nonterminalKindCABI['MappingKeyType'] = 91] = 'MappingKeyType';
nonterminalKindCABI[nonterminalKindCABI['MappingType'] = 92] = 'MappingType';
nonterminalKindCABI[nonterminalKindCABI['MappingValue'] = 93] = 'MappingValue';
nonterminalKindCABI[nonterminalKindCABI['MemberAccessExpression'] = 94] = 'MemberAccessExpression';
nonterminalKindCABI[nonterminalKindCABI['ModifierAttribute'] = 95] = 'ModifierAttribute';
nonterminalKindCABI[nonterminalKindCABI['ModifierAttributes'] = 96] = 'ModifierAttributes';
nonterminalKindCABI[nonterminalKindCABI['ModifierDefinition'] = 97] = 'ModifierDefinition';
nonterminalKindCABI[nonterminalKindCABI['ModifierInvocation'] = 98] = 'ModifierInvocation';
nonterminalKindCABI[nonterminalKindCABI['MultiplicativeExpression'] = 99] = 'MultiplicativeExpression';
nonterminalKindCABI[nonterminalKindCABI['NamedArgument'] = 100] = 'NamedArgument';
nonterminalKindCABI[nonterminalKindCABI['NamedArgumentGroup'] = 101] = 'NamedArgumentGroup';
nonterminalKindCABI[nonterminalKindCABI['NamedArguments'] = 102] = 'NamedArguments';
nonterminalKindCABI[nonterminalKindCABI['NamedArgumentsDeclaration'] = 103] = 'NamedArgumentsDeclaration';
nonterminalKindCABI[nonterminalKindCABI['NamedImport'] = 104] = 'NamedImport';
nonterminalKindCABI[nonterminalKindCABI['NewExpression'] = 105] = 'NewExpression';
nonterminalKindCABI[nonterminalKindCABI['NumberUnit'] = 106] = 'NumberUnit';
nonterminalKindCABI[nonterminalKindCABI['OrExpression'] = 107] = 'OrExpression';
nonterminalKindCABI[nonterminalKindCABI['OverridePaths'] = 108] = 'OverridePaths';
nonterminalKindCABI[nonterminalKindCABI['OverridePathsDeclaration'] = 109] = 'OverridePathsDeclaration';
nonterminalKindCABI[nonterminalKindCABI['OverrideSpecifier'] = 110] = 'OverrideSpecifier';
nonterminalKindCABI[nonterminalKindCABI['Parameter'] = 111] = 'Parameter';
nonterminalKindCABI[nonterminalKindCABI['Parameters'] = 112] = 'Parameters';
nonterminalKindCABI[nonterminalKindCABI['ParametersDeclaration'] = 113] = 'ParametersDeclaration';
nonterminalKindCABI[nonterminalKindCABI['PathImport'] = 114] = 'PathImport';
nonterminalKindCABI[nonterminalKindCABI['PositionalArguments'] = 115] = 'PositionalArguments';
nonterminalKindCABI[nonterminalKindCABI['PositionalArgumentsDeclaration'] = 116] = 'PositionalArgumentsDeclaration';
nonterminalKindCABI[nonterminalKindCABI['PostfixExpression'] = 117] = 'PostfixExpression';
nonterminalKindCABI[nonterminalKindCABI['Pragma'] = 118] = 'Pragma';
nonterminalKindCABI[nonterminalKindCABI['PragmaDirective'] = 119] = 'PragmaDirective';
nonterminalKindCABI[nonterminalKindCABI['PrefixExpression'] = 120] = 'PrefixExpression';
nonterminalKindCABI[nonterminalKindCABI['ReceiveFunctionAttribute'] = 121] = 'ReceiveFunctionAttribute';
nonterminalKindCABI[nonterminalKindCABI['ReceiveFunctionAttributes'] = 122] = 'ReceiveFunctionAttributes';
nonterminalKindCABI[nonterminalKindCABI['ReceiveFunctionDefinition'] = 123] = 'ReceiveFunctionDefinition';
nonterminalKindCABI[nonterminalKindCABI['ReturnStatement'] = 124] = 'ReturnStatement';
nonterminalKindCABI[nonterminalKindCABI['ReturnsDeclaration'] = 125] = 'ReturnsDeclaration';
nonterminalKindCABI[nonterminalKindCABI['RevertStatement'] = 126] = 'RevertStatement';
nonterminalKindCABI[nonterminalKindCABI['ShiftExpression'] = 127] = 'ShiftExpression';
nonterminalKindCABI[nonterminalKindCABI['SimpleVersionLiteral'] = 128] = 'SimpleVersionLiteral';
nonterminalKindCABI[nonterminalKindCABI['SourceUnit'] = 129] = 'SourceUnit';
nonterminalKindCABI[nonterminalKindCABI['SourceUnitMember'] = 130] = 'SourceUnitMember';
nonterminalKindCABI[nonterminalKindCABI['SourceUnitMembers'] = 131] = 'SourceUnitMembers';
nonterminalKindCABI[nonterminalKindCABI['StateVariableAttribute'] = 132] = 'StateVariableAttribute';
nonterminalKindCABI[nonterminalKindCABI['StateVariableAttributes'] = 133] = 'StateVariableAttributes';
nonterminalKindCABI[nonterminalKindCABI['StateVariableDefinition'] = 134] = 'StateVariableDefinition';
nonterminalKindCABI[nonterminalKindCABI['StateVariableDefinitionValue'] = 135] = 'StateVariableDefinitionValue';
nonterminalKindCABI[nonterminalKindCABI['Statement'] = 136] = 'Statement';
nonterminalKindCABI[nonterminalKindCABI['Statements'] = 137] = 'Statements';
nonterminalKindCABI[nonterminalKindCABI['StorageLayoutSpecifier'] = 138] = 'StorageLayoutSpecifier';
nonterminalKindCABI[nonterminalKindCABI['StorageLocation'] = 139] = 'StorageLocation';
nonterminalKindCABI[nonterminalKindCABI['StringExpression'] = 140] = 'StringExpression';
nonterminalKindCABI[nonterminalKindCABI['StringLiteral'] = 141] = 'StringLiteral';
nonterminalKindCABI[nonterminalKindCABI['StringLiterals'] = 142] = 'StringLiterals';
nonterminalKindCABI[nonterminalKindCABI['StructDefinition'] = 143] = 'StructDefinition';
nonterminalKindCABI[nonterminalKindCABI['StructMember'] = 144] = 'StructMember';
nonterminalKindCABI[nonterminalKindCABI['StructMembers'] = 145] = 'StructMembers';
nonterminalKindCABI[nonterminalKindCABI['ThrowStatement'] = 146] = 'ThrowStatement';
nonterminalKindCABI[nonterminalKindCABI['TryStatement'] = 147] = 'TryStatement';
nonterminalKindCABI[nonterminalKindCABI['TupleDeconstructionElement'] = 148] = 'TupleDeconstructionElement';
nonterminalKindCABI[nonterminalKindCABI['TupleDeconstructionElements'] = 149] = 'TupleDeconstructionElements';
nonterminalKindCABI[nonterminalKindCABI['TupleDeconstructionStatement'] = 150] = 'TupleDeconstructionStatement';
nonterminalKindCABI[nonterminalKindCABI['TupleExpression'] = 151] = 'TupleExpression';
nonterminalKindCABI[nonterminalKindCABI['TupleMember'] = 152] = 'TupleMember';
nonterminalKindCABI[nonterminalKindCABI['TupleValue'] = 153] = 'TupleValue';
nonterminalKindCABI[nonterminalKindCABI['TupleValues'] = 154] = 'TupleValues';
nonterminalKindCABI[nonterminalKindCABI['TypeExpression'] = 155] = 'TypeExpression';
nonterminalKindCABI[nonterminalKindCABI['TypeName'] = 156] = 'TypeName';
nonterminalKindCABI[nonterminalKindCABI['TypedTupleMember'] = 157] = 'TypedTupleMember';
nonterminalKindCABI[nonterminalKindCABI['UncheckedBlock'] = 158] = 'UncheckedBlock';
nonterminalKindCABI[nonterminalKindCABI['UnicodeStringLiteral'] = 159] = 'UnicodeStringLiteral';
nonterminalKindCABI[nonterminalKindCABI['UnicodeStringLiterals'] = 160] = 'UnicodeStringLiterals';
nonterminalKindCABI[nonterminalKindCABI['UnnamedFunctionAttribute'] = 161] = 'UnnamedFunctionAttribute';
nonterminalKindCABI[nonterminalKindCABI['UnnamedFunctionAttributes'] = 162] = 'UnnamedFunctionAttributes';
nonterminalKindCABI[nonterminalKindCABI['UnnamedFunctionDefinition'] = 163] = 'UnnamedFunctionDefinition';
nonterminalKindCABI[nonterminalKindCABI['UntypedTupleMember'] = 164] = 'UntypedTupleMember';
nonterminalKindCABI[nonterminalKindCABI['UserDefinedValueTypeDefinition'] = 165] = 'UserDefinedValueTypeDefinition';
nonterminalKindCABI[nonterminalKindCABI['UsingAlias'] = 166] = 'UsingAlias';
nonterminalKindCABI[nonterminalKindCABI['UsingClause'] = 167] = 'UsingClause';
nonterminalKindCABI[nonterminalKindCABI['UsingDeconstruction'] = 168] = 'UsingDeconstruction';
nonterminalKindCABI[nonterminalKindCABI['UsingDeconstructionSymbol'] = 169] = 'UsingDeconstructionSymbol';
nonterminalKindCABI[nonterminalKindCABI['UsingDeconstructionSymbols'] = 170] = 'UsingDeconstructionSymbols';
nonterminalKindCABI[nonterminalKindCABI['UsingDirective'] = 171] = 'UsingDirective';
nonterminalKindCABI[nonterminalKindCABI['UsingOperator'] = 172] = 'UsingOperator';
nonterminalKindCABI[nonterminalKindCABI['UsingTarget'] = 173] = 'UsingTarget';
nonterminalKindCABI[nonterminalKindCABI['VariableDeclarationStatement'] = 174] = 'VariableDeclarationStatement';
nonterminalKindCABI[nonterminalKindCABI['VariableDeclarationType'] = 175] = 'VariableDeclarationType';
nonterminalKindCABI[nonterminalKindCABI['VariableDeclarationValue'] = 176] = 'VariableDeclarationValue';
nonterminalKindCABI[nonterminalKindCABI['VersionExpression'] = 177] = 'VersionExpression';
nonterminalKindCABI[nonterminalKindCABI['VersionExpressionSet'] = 178] = 'VersionExpressionSet';
nonterminalKindCABI[nonterminalKindCABI['VersionExpressionSets'] = 179] = 'VersionExpressionSets';
nonterminalKindCABI[nonterminalKindCABI['VersionLiteral'] = 180] = 'VersionLiteral';
nonterminalKindCABI[nonterminalKindCABI['VersionOperator'] = 181] = 'VersionOperator';
nonterminalKindCABI[nonterminalKindCABI['VersionPragma'] = 182] = 'VersionPragma';
nonterminalKindCABI[nonterminalKindCABI['VersionRange'] = 183] = 'VersionRange';
nonterminalKindCABI[nonterminalKindCABI['VersionTerm'] = 184] = 'VersionTerm';
nonterminalKindCABI[nonterminalKindCABI['WhileStatement'] = 185] = 'WhileStatement';
nonterminalKindCABI[nonterminalKindCABI['YulArguments'] = 186] = 'YulArguments';
nonterminalKindCABI[nonterminalKindCABI['YulAssignmentOperator'] = 187] = 'YulAssignmentOperator';
nonterminalKindCABI[nonterminalKindCABI['YulBlock'] = 188] = 'YulBlock';
nonterminalKindCABI[nonterminalKindCABI['YulBreakStatement'] = 189] = 'YulBreakStatement';
nonterminalKindCABI[nonterminalKindCABI['YulColonAndEqual'] = 190] = 'YulColonAndEqual';
nonterminalKindCABI[nonterminalKindCABI['YulContinueStatement'] = 191] = 'YulContinueStatement';
nonterminalKindCABI[nonterminalKindCABI['YulDefaultCase'] = 192] = 'YulDefaultCase';
nonterminalKindCABI[nonterminalKindCABI['YulEqualAndColon'] = 193] = 'YulEqualAndColon';
nonterminalKindCABI[nonterminalKindCABI['YulExpression'] = 194] = 'YulExpression';
nonterminalKindCABI[nonterminalKindCABI['YulForStatement'] = 195] = 'YulForStatement';
nonterminalKindCABI[nonterminalKindCABI['YulFunctionCallExpression'] = 196] = 'YulFunctionCallExpression';
nonterminalKindCABI[nonterminalKindCABI['YulFunctionDefinition'] = 197] = 'YulFunctionDefinition';
nonterminalKindCABI[nonterminalKindCABI['YulIfStatement'] = 198] = 'YulIfStatement';
nonterminalKindCABI[nonterminalKindCABI['YulLabel'] = 199] = 'YulLabel';
nonterminalKindCABI[nonterminalKindCABI['YulLeaveStatement'] = 200] = 'YulLeaveStatement';
nonterminalKindCABI[nonterminalKindCABI['YulLiteral'] = 201] = 'YulLiteral';
nonterminalKindCABI[nonterminalKindCABI['YulParameters'] = 202] = 'YulParameters';
nonterminalKindCABI[nonterminalKindCABI['YulParametersDeclaration'] = 203] = 'YulParametersDeclaration';
nonterminalKindCABI[nonterminalKindCABI['YulPath'] = 204] = 'YulPath';
nonterminalKindCABI[nonterminalKindCABI['YulPaths'] = 205] = 'YulPaths';
nonterminalKindCABI[nonterminalKindCABI['YulReturnsDeclaration'] = 206] = 'YulReturnsDeclaration';
nonterminalKindCABI[nonterminalKindCABI['YulStackAssignmentOperator'] = 207] = 'YulStackAssignmentOperator';
nonterminalKindCABI[nonterminalKindCABI['YulStackAssignmentStatement'] = 208] = 'YulStackAssignmentStatement';
nonterminalKindCABI[nonterminalKindCABI['YulStatement'] = 209] = 'YulStatement';
nonterminalKindCABI[nonterminalKindCABI['YulStatements'] = 210] = 'YulStatements';
nonterminalKindCABI[nonterminalKindCABI['YulSwitchCase'] = 211] = 'YulSwitchCase';
nonterminalKindCABI[nonterminalKindCABI['YulSwitchCases'] = 212] = 'YulSwitchCases';
nonterminalKindCABI[nonterminalKindCABI['YulSwitchStatement'] = 213] = 'YulSwitchStatement';
nonterminalKindCABI[nonterminalKindCABI['YulValueCase'] = 214] = 'YulValueCase';
nonterminalKindCABI[nonterminalKindCABI['YulVariableAssignmentStatement'] = 215] = 'YulVariableAssignmentStatement';
nonterminalKindCABI[nonterminalKindCABI['YulVariableDeclarationStatement'] = 216] = 'YulVariableDeclarationStatement';
nonterminalKindCABI[nonterminalKindCABI['YulVariableDeclarationValue'] = 217] = 'YulVariableDeclarationValue';
nonterminalKindCABI[nonterminalKindCABI['YulVariableNames'] = 218] = 'YulVariableNames';

var terminalKind = {};
terminalKind['Unrecognized'] = 'Unrecognized';
terminalKind['Missing'] = 'Missing';
terminalKind['AbicoderKeyword'] = 'AbicoderKeyword';
terminalKind['AbstractKeyword'] = 'AbstractKeyword';
terminalKind['AddressKeyword'] = 'AddressKeyword';
terminalKind['AfterKeyword'] = 'AfterKeyword';
terminalKind['AliasKeyword'] = 'AliasKeyword';
terminalKind['Ampersand'] = 'Ampersand';
terminalKind['AmpersandAmpersand'] = 'AmpersandAmpersand';
terminalKind['AmpersandEqual'] = 'AmpersandEqual';
terminalKind['AnonymousKeyword'] = 'AnonymousKeyword';
terminalKind['ApplyKeyword'] = 'ApplyKeyword';
terminalKind['AsKeyword'] = 'AsKeyword';
terminalKind['AssemblyKeyword'] = 'AssemblyKeyword';
terminalKind['Asterisk'] = 'Asterisk';
terminalKind['AsteriskAsterisk'] = 'AsteriskAsterisk';
terminalKind['AsteriskEqual'] = 'AsteriskEqual';
terminalKind['AtKeyword'] = 'AtKeyword';
terminalKind['AutoKeyword'] = 'AutoKeyword';
terminalKind['Bang'] = 'Bang';
terminalKind['BangEqual'] = 'BangEqual';
terminalKind['Bar'] = 'Bar';
terminalKind['BarBar'] = 'BarBar';
terminalKind['BarEqual'] = 'BarEqual';
terminalKind['BoolKeyword'] = 'BoolKeyword';
terminalKind['BreakKeyword'] = 'BreakKeyword';
terminalKind['ByteKeyword'] = 'ByteKeyword';
terminalKind['BytesKeyword'] = 'BytesKeyword';
terminalKind['CallDataKeyword'] = 'CallDataKeyword';
terminalKind['Caret'] = 'Caret';
terminalKind['CaretEqual'] = 'CaretEqual';
terminalKind['CaseKeyword'] = 'CaseKeyword';
terminalKind['CatchKeyword'] = 'CatchKeyword';
terminalKind['CloseBrace'] = 'CloseBrace';
terminalKind['CloseBracket'] = 'CloseBracket';
terminalKind['CloseParen'] = 'CloseParen';
terminalKind['Colon'] = 'Colon';
terminalKind['ColonEqual'] = 'ColonEqual';
terminalKind['Comma'] = 'Comma';
terminalKind['ConstantKeyword'] = 'ConstantKeyword';
terminalKind['ConstructorKeyword'] = 'ConstructorKeyword';
terminalKind['ContinueKeyword'] = 'ContinueKeyword';
terminalKind['ContractKeyword'] = 'ContractKeyword';
terminalKind['CopyOfKeyword'] = 'CopyOfKeyword';
terminalKind['DaysKeyword'] = 'DaysKeyword';
terminalKind['DecimalLiteral'] = 'DecimalLiteral';
terminalKind['DefaultKeyword'] = 'DefaultKeyword';
terminalKind['DefineKeyword'] = 'DefineKeyword';
terminalKind['DeleteKeyword'] = 'DeleteKeyword';
terminalKind['DoKeyword'] = 'DoKeyword';
terminalKind['DoubleQuotedHexStringLiteral'] = 'DoubleQuotedHexStringLiteral';
terminalKind['DoubleQuotedStringLiteral'] = 'DoubleQuotedStringLiteral';
terminalKind['DoubleQuotedUnicodeStringLiteral'] = 'DoubleQuotedUnicodeStringLiteral';
terminalKind['DoubleQuotedVersionLiteral'] = 'DoubleQuotedVersionLiteral';
terminalKind['ElseKeyword'] = 'ElseKeyword';
terminalKind['EmitKeyword'] = 'EmitKeyword';
terminalKind['EndOfLine'] = 'EndOfLine';
terminalKind['EnumKeyword'] = 'EnumKeyword';
terminalKind['Equal'] = 'Equal';
terminalKind['EqualColon'] = 'EqualColon';
terminalKind['EqualEqual'] = 'EqualEqual';
terminalKind['EqualGreaterThan'] = 'EqualGreaterThan';
terminalKind['ErrorKeyword'] = 'ErrorKeyword';
terminalKind['EtherKeyword'] = 'EtherKeyword';
terminalKind['EventKeyword'] = 'EventKeyword';
terminalKind['ExperimentalKeyword'] = 'ExperimentalKeyword';
terminalKind['ExternalKeyword'] = 'ExternalKeyword';
terminalKind['FallbackKeyword'] = 'FallbackKeyword';
terminalKind['FalseKeyword'] = 'FalseKeyword';
terminalKind['FinalKeyword'] = 'FinalKeyword';
terminalKind['FinneyKeyword'] = 'FinneyKeyword';
terminalKind['FixedKeyword'] = 'FixedKeyword';
terminalKind['ForKeyword'] = 'ForKeyword';
terminalKind['FromKeyword'] = 'FromKeyword';
terminalKind['FunctionKeyword'] = 'FunctionKeyword';
terminalKind['GlobalKeyword'] = 'GlobalKeyword';
terminalKind['GreaterThan'] = 'GreaterThan';
terminalKind['GreaterThanEqual'] = 'GreaterThanEqual';
terminalKind['GreaterThanGreaterThan'] = 'GreaterThanGreaterThan';
terminalKind['GreaterThanGreaterThanEqual'] = 'GreaterThanGreaterThanEqual';
terminalKind['GreaterThanGreaterThanGreaterThan'] = 'GreaterThanGreaterThanGreaterThan';
terminalKind['GreaterThanGreaterThanGreaterThanEqual'] = 'GreaterThanGreaterThanGreaterThanEqual';
terminalKind['GweiKeyword'] = 'GweiKeyword';
terminalKind['HexKeyword'] = 'HexKeyword';
terminalKind['HexLiteral'] = 'HexLiteral';
terminalKind['HoursKeyword'] = 'HoursKeyword';
terminalKind['Identifier'] = 'Identifier';
terminalKind['IfKeyword'] = 'IfKeyword';
terminalKind['ImmutableKeyword'] = 'ImmutableKeyword';
terminalKind['ImplementsKeyword'] = 'ImplementsKeyword';
terminalKind['ImportKeyword'] = 'ImportKeyword';
terminalKind['InKeyword'] = 'InKeyword';
terminalKind['IndexedKeyword'] = 'IndexedKeyword';
terminalKind['InlineKeyword'] = 'InlineKeyword';
terminalKind['IntKeyword'] = 'IntKeyword';
terminalKind['InterfaceKeyword'] = 'InterfaceKeyword';
terminalKind['InternalKeyword'] = 'InternalKeyword';
terminalKind['IsKeyword'] = 'IsKeyword';
terminalKind['LayoutKeyword'] = 'LayoutKeyword';
terminalKind['LessThan'] = 'LessThan';
terminalKind['LessThanEqual'] = 'LessThanEqual';
terminalKind['LessThanLessThan'] = 'LessThanLessThan';
terminalKind['LessThanLessThanEqual'] = 'LessThanLessThanEqual';
terminalKind['LetKeyword'] = 'LetKeyword';
terminalKind['LibraryKeyword'] = 'LibraryKeyword';
terminalKind['MacroKeyword'] = 'MacroKeyword';
terminalKind['MappingKeyword'] = 'MappingKeyword';
terminalKind['MatchKeyword'] = 'MatchKeyword';
terminalKind['MemoryKeyword'] = 'MemoryKeyword';
terminalKind['Minus'] = 'Minus';
terminalKind['MinusEqual'] = 'MinusEqual';
terminalKind['MinusGreaterThan'] = 'MinusGreaterThan';
terminalKind['MinusMinus'] = 'MinusMinus';
terminalKind['MinutesKeyword'] = 'MinutesKeyword';
terminalKind['ModifierKeyword'] = 'ModifierKeyword';
terminalKind['MultiLineComment'] = 'MultiLineComment';
terminalKind['MultiLineNatSpecComment'] = 'MultiLineNatSpecComment';
terminalKind['MutableKeyword'] = 'MutableKeyword';
terminalKind['NewKeyword'] = 'NewKeyword';
terminalKind['NullKeyword'] = 'NullKeyword';
terminalKind['OfKeyword'] = 'OfKeyword';
terminalKind['OpenBrace'] = 'OpenBrace';
terminalKind['OpenBracket'] = 'OpenBracket';
terminalKind['OpenParen'] = 'OpenParen';
terminalKind['OverrideKeyword'] = 'OverrideKeyword';
terminalKind['PartialKeyword'] = 'PartialKeyword';
terminalKind['PayableKeyword'] = 'PayableKeyword';
terminalKind['Percent'] = 'Percent';
terminalKind['PercentEqual'] = 'PercentEqual';
terminalKind['Period'] = 'Period';
terminalKind['Plus'] = 'Plus';
terminalKind['PlusEqual'] = 'PlusEqual';
terminalKind['PlusPlus'] = 'PlusPlus';
terminalKind['PragmaKeyword'] = 'PragmaKeyword';
terminalKind['PrivateKeyword'] = 'PrivateKeyword';
terminalKind['PromiseKeyword'] = 'PromiseKeyword';
terminalKind['PublicKeyword'] = 'PublicKeyword';
terminalKind['PureKeyword'] = 'PureKeyword';
terminalKind['QuestionMark'] = 'QuestionMark';
terminalKind['ReceiveKeyword'] = 'ReceiveKeyword';
terminalKind['ReferenceKeyword'] = 'ReferenceKeyword';
terminalKind['RelocatableKeyword'] = 'RelocatableKeyword';
terminalKind['ReturnKeyword'] = 'ReturnKeyword';
terminalKind['ReturnsKeyword'] = 'ReturnsKeyword';
terminalKind['RevertKeyword'] = 'RevertKeyword';
terminalKind['SealedKeyword'] = 'SealedKeyword';
terminalKind['SecondsKeyword'] = 'SecondsKeyword';
terminalKind['Semicolon'] = 'Semicolon';
terminalKind['SingleLineComment'] = 'SingleLineComment';
terminalKind['SingleLineNatSpecComment'] = 'SingleLineNatSpecComment';
terminalKind['SingleQuotedHexStringLiteral'] = 'SingleQuotedHexStringLiteral';
terminalKind['SingleQuotedStringLiteral'] = 'SingleQuotedStringLiteral';
terminalKind['SingleQuotedUnicodeStringLiteral'] = 'SingleQuotedUnicodeStringLiteral';
terminalKind['SingleQuotedVersionLiteral'] = 'SingleQuotedVersionLiteral';
terminalKind['SizeOfKeyword'] = 'SizeOfKeyword';
terminalKind['Slash'] = 'Slash';
terminalKind['SlashEqual'] = 'SlashEqual';
terminalKind['SolidityKeyword'] = 'SolidityKeyword';
terminalKind['StaticKeyword'] = 'StaticKeyword';
terminalKind['StorageKeyword'] = 'StorageKeyword';
terminalKind['StringKeyword'] = 'StringKeyword';
terminalKind['StructKeyword'] = 'StructKeyword';
terminalKind['SuperKeyword'] = 'SuperKeyword';
terminalKind['SupportsKeyword'] = 'SupportsKeyword';
terminalKind['SwitchKeyword'] = 'SwitchKeyword';
terminalKind['SzaboKeyword'] = 'SzaboKeyword';
terminalKind['ThisKeyword'] = 'ThisKeyword';
terminalKind['ThrowKeyword'] = 'ThrowKeyword';
terminalKind['Tilde'] = 'Tilde';
terminalKind['TransientKeyword'] = 'TransientKeyword';
terminalKind['TrueKeyword'] = 'TrueKeyword';
terminalKind['TryKeyword'] = 'TryKeyword';
terminalKind['TypeDefKeyword'] = 'TypeDefKeyword';
terminalKind['TypeKeyword'] = 'TypeKeyword';
terminalKind['TypeOfKeyword'] = 'TypeOfKeyword';
terminalKind['UfixedKeyword'] = 'UfixedKeyword';
terminalKind['UintKeyword'] = 'UintKeyword';
terminalKind['UncheckedKeyword'] = 'UncheckedKeyword';
terminalKind['UsingKeyword'] = 'UsingKeyword';
terminalKind['VarKeyword'] = 'VarKeyword';
terminalKind['VersionSpecifier'] = 'VersionSpecifier';
terminalKind['ViewKeyword'] = 'ViewKeyword';
terminalKind['VirtualKeyword'] = 'VirtualKeyword';
terminalKind['WeeksKeyword'] = 'WeeksKeyword';
terminalKind['WeiKeyword'] = 'WeiKeyword';
terminalKind['WhileKeyword'] = 'WhileKeyword';
terminalKind['Whitespace'] = 'Whitespace';
terminalKind['YearsKeyword'] = 'YearsKeyword';
terminalKind['YulAbstractKeyword'] = 'YulAbstractKeyword';
terminalKind['YulAfterKeyword'] = 'YulAfterKeyword';
terminalKind['YulAliasKeyword'] = 'YulAliasKeyword';
terminalKind['YulAnonymousKeyword'] = 'YulAnonymousKeyword';
terminalKind['YulApplyKeyword'] = 'YulApplyKeyword';
terminalKind['YulAsKeyword'] = 'YulAsKeyword';
terminalKind['YulAssemblyKeyword'] = 'YulAssemblyKeyword';
terminalKind['YulAutoKeyword'] = 'YulAutoKeyword';
terminalKind['YulBoolKeyword'] = 'YulBoolKeyword';
terminalKind['YulBreakKeyword'] = 'YulBreakKeyword';
terminalKind['YulBytesKeyword'] = 'YulBytesKeyword';
terminalKind['YulCallDataKeyword'] = 'YulCallDataKeyword';
terminalKind['YulCaseKeyword'] = 'YulCaseKeyword';
terminalKind['YulCatchKeyword'] = 'YulCatchKeyword';
terminalKind['YulConstantKeyword'] = 'YulConstantKeyword';
terminalKind['YulConstructorKeyword'] = 'YulConstructorKeyword';
terminalKind['YulContinueKeyword'] = 'YulContinueKeyword';
terminalKind['YulContractKeyword'] = 'YulContractKeyword';
terminalKind['YulCopyOfKeyword'] = 'YulCopyOfKeyword';
terminalKind['YulDaysKeyword'] = 'YulDaysKeyword';
terminalKind['YulDecimalLiteral'] = 'YulDecimalLiteral';
terminalKind['YulDefaultKeyword'] = 'YulDefaultKeyword';
terminalKind['YulDefineKeyword'] = 'YulDefineKeyword';
terminalKind['YulDeleteKeyword'] = 'YulDeleteKeyword';
terminalKind['YulDoKeyword'] = 'YulDoKeyword';
terminalKind['YulElseKeyword'] = 'YulElseKeyword';
terminalKind['YulEmitKeyword'] = 'YulEmitKeyword';
terminalKind['YulEnumKeyword'] = 'YulEnumKeyword';
terminalKind['YulEtherKeyword'] = 'YulEtherKeyword';
terminalKind['YulEventKeyword'] = 'YulEventKeyword';
terminalKind['YulExternalKeyword'] = 'YulExternalKeyword';
terminalKind['YulFallbackKeyword'] = 'YulFallbackKeyword';
terminalKind['YulFalseKeyword'] = 'YulFalseKeyword';
terminalKind['YulFinalKeyword'] = 'YulFinalKeyword';
terminalKind['YulFinneyKeyword'] = 'YulFinneyKeyword';
terminalKind['YulFixedKeyword'] = 'YulFixedKeyword';
terminalKind['YulForKeyword'] = 'YulForKeyword';
terminalKind['YulFunctionKeyword'] = 'YulFunctionKeyword';
terminalKind['YulGweiKeyword'] = 'YulGweiKeyword';
terminalKind['YulHexKeyword'] = 'YulHexKeyword';
terminalKind['YulHexLiteral'] = 'YulHexLiteral';
terminalKind['YulHoursKeyword'] = 'YulHoursKeyword';
terminalKind['YulIdentifier'] = 'YulIdentifier';
terminalKind['YulIfKeyword'] = 'YulIfKeyword';
terminalKind['YulImmutableKeyword'] = 'YulImmutableKeyword';
terminalKind['YulImplementsKeyword'] = 'YulImplementsKeyword';
terminalKind['YulImportKeyword'] = 'YulImportKeyword';
terminalKind['YulInKeyword'] = 'YulInKeyword';
terminalKind['YulIndexedKeyword'] = 'YulIndexedKeyword';
terminalKind['YulInlineKeyword'] = 'YulInlineKeyword';
terminalKind['YulIntKeyword'] = 'YulIntKeyword';
terminalKind['YulInterfaceKeyword'] = 'YulInterfaceKeyword';
terminalKind['YulInternalKeyword'] = 'YulInternalKeyword';
terminalKind['YulIsKeyword'] = 'YulIsKeyword';
terminalKind['YulLeaveKeyword'] = 'YulLeaveKeyword';
terminalKind['YulLetKeyword'] = 'YulLetKeyword';
terminalKind['YulLibraryKeyword'] = 'YulLibraryKeyword';
terminalKind['YulMacroKeyword'] = 'YulMacroKeyword';
terminalKind['YulMappingKeyword'] = 'YulMappingKeyword';
terminalKind['YulMatchKeyword'] = 'YulMatchKeyword';
terminalKind['YulMemoryKeyword'] = 'YulMemoryKeyword';
terminalKind['YulMinutesKeyword'] = 'YulMinutesKeyword';
terminalKind['YulModifierKeyword'] = 'YulModifierKeyword';
terminalKind['YulMutableKeyword'] = 'YulMutableKeyword';
terminalKind['YulNewKeyword'] = 'YulNewKeyword';
terminalKind['YulNullKeyword'] = 'YulNullKeyword';
terminalKind['YulOfKeyword'] = 'YulOfKeyword';
terminalKind['YulOverrideKeyword'] = 'YulOverrideKeyword';
terminalKind['YulPartialKeyword'] = 'YulPartialKeyword';
terminalKind['YulPayableKeyword'] = 'YulPayableKeyword';
terminalKind['YulPragmaKeyword'] = 'YulPragmaKeyword';
terminalKind['YulPrivateKeyword'] = 'YulPrivateKeyword';
terminalKind['YulPromiseKeyword'] = 'YulPromiseKeyword';
terminalKind['YulPublicKeyword'] = 'YulPublicKeyword';
terminalKind['YulPureKeyword'] = 'YulPureKeyword';
terminalKind['YulReceiveKeyword'] = 'YulReceiveKeyword';
terminalKind['YulReferenceKeyword'] = 'YulReferenceKeyword';
terminalKind['YulRelocatableKeyword'] = 'YulRelocatableKeyword';
terminalKind['YulReturnsKeyword'] = 'YulReturnsKeyword';
terminalKind['YulSealedKeyword'] = 'YulSealedKeyword';
terminalKind['YulSecondsKeyword'] = 'YulSecondsKeyword';
terminalKind['YulSizeOfKeyword'] = 'YulSizeOfKeyword';
terminalKind['YulStaticKeyword'] = 'YulStaticKeyword';
terminalKind['YulStorageKeyword'] = 'YulStorageKeyword';
terminalKind['YulStringKeyword'] = 'YulStringKeyword';
terminalKind['YulStructKeyword'] = 'YulStructKeyword';
terminalKind['YulSuperKeyword'] = 'YulSuperKeyword';
terminalKind['YulSupportsKeyword'] = 'YulSupportsKeyword';
terminalKind['YulSwitchKeyword'] = 'YulSwitchKeyword';
terminalKind['YulSzaboKeyword'] = 'YulSzaboKeyword';
terminalKind['YulThisKeyword'] = 'YulThisKeyword';
terminalKind['YulThrowKeyword'] = 'YulThrowKeyword';
terminalKind['YulTrueKeyword'] = 'YulTrueKeyword';
terminalKind['YulTryKeyword'] = 'YulTryKeyword';
terminalKind['YulTypeDefKeyword'] = 'YulTypeDefKeyword';
terminalKind['YulTypeKeyword'] = 'YulTypeKeyword';
terminalKind['YulTypeOfKeyword'] = 'YulTypeOfKeyword';
terminalKind['YulUfixedKeyword'] = 'YulUfixedKeyword';
terminalKind['YulUintKeyword'] = 'YulUintKeyword';
terminalKind['YulUncheckedKeyword'] = 'YulUncheckedKeyword';
terminalKind['YulUsingKeyword'] = 'YulUsingKeyword';
terminalKind['YulVarKeyword'] = 'YulVarKeyword';
terminalKind['YulViewKeyword'] = 'YulViewKeyword';
terminalKind['YulVirtualKeyword'] = 'YulVirtualKeyword';
terminalKind['YulWeeksKeyword'] = 'YulWeeksKeyword';
terminalKind['YulWeiKeyword'] = 'YulWeiKeyword';
terminalKind['YulWhileKeyword'] = 'YulWhileKeyword';
terminalKind['YulYearsKeyword'] = 'YulYearsKeyword';

var terminalKindCABI = {};
terminalKindCABI[terminalKindCABI['Unrecognized'] = 0] = 'Unrecognized';
terminalKindCABI[terminalKindCABI['Missing'] = 1] = 'Missing';
terminalKindCABI[terminalKindCABI['AbicoderKeyword'] = 2] = 'AbicoderKeyword';
terminalKindCABI[terminalKindCABI['AbstractKeyword'] = 3] = 'AbstractKeyword';
terminalKindCABI[terminalKindCABI['AddressKeyword'] = 4] = 'AddressKeyword';
terminalKindCABI[terminalKindCABI['AfterKeyword'] = 5] = 'AfterKeyword';
terminalKindCABI[terminalKindCABI['AliasKeyword'] = 6] = 'AliasKeyword';
terminalKindCABI[terminalKindCABI['Ampersand'] = 7] = 'Ampersand';
terminalKindCABI[terminalKindCABI['AmpersandAmpersand'] = 8] = 'AmpersandAmpersand';
terminalKindCABI[terminalKindCABI['AmpersandEqual'] = 9] = 'AmpersandEqual';
terminalKindCABI[terminalKindCABI['AnonymousKeyword'] = 10] = 'AnonymousKeyword';
terminalKindCABI[terminalKindCABI['ApplyKeyword'] = 11] = 'ApplyKeyword';
terminalKindCABI[terminalKindCABI['AsKeyword'] = 12] = 'AsKeyword';
terminalKindCABI[terminalKindCABI['AssemblyKeyword'] = 13] = 'AssemblyKeyword';
terminalKindCABI[terminalKindCABI['Asterisk'] = 14] = 'Asterisk';
terminalKindCABI[terminalKindCABI['AsteriskAsterisk'] = 15] = 'AsteriskAsterisk';
terminalKindCABI[terminalKindCABI['AsteriskEqual'] = 16] = 'AsteriskEqual';
terminalKindCABI[terminalKindCABI['AtKeyword'] = 17] = 'AtKeyword';
terminalKindCABI[terminalKindCABI['AutoKeyword'] = 18] = 'AutoKeyword';
terminalKindCABI[terminalKindCABI['Bang'] = 19] = 'Bang';
terminalKindCABI[terminalKindCABI['BangEqual'] = 20] = 'BangEqual';
terminalKindCABI[terminalKindCABI['Bar'] = 21] = 'Bar';
terminalKindCABI[terminalKindCABI['BarBar'] = 22] = 'BarBar';
terminalKindCABI[terminalKindCABI['BarEqual'] = 23] = 'BarEqual';
terminalKindCABI[terminalKindCABI['BoolKeyword'] = 24] = 'BoolKeyword';
terminalKindCABI[terminalKindCABI['BreakKeyword'] = 25] = 'BreakKeyword';
terminalKindCABI[terminalKindCABI['ByteKeyword'] = 26] = 'ByteKeyword';
terminalKindCABI[terminalKindCABI['BytesKeyword'] = 27] = 'BytesKeyword';
terminalKindCABI[terminalKindCABI['CallDataKeyword'] = 28] = 'CallDataKeyword';
terminalKindCABI[terminalKindCABI['Caret'] = 29] = 'Caret';
terminalKindCABI[terminalKindCABI['CaretEqual'] = 30] = 'CaretEqual';
terminalKindCABI[terminalKindCABI['CaseKeyword'] = 31] = 'CaseKeyword';
terminalKindCABI[terminalKindCABI['CatchKeyword'] = 32] = 'CatchKeyword';
terminalKindCABI[terminalKindCABI['CloseBrace'] = 33] = 'CloseBrace';
terminalKindCABI[terminalKindCABI['CloseBracket'] = 34] = 'CloseBracket';
terminalKindCABI[terminalKindCABI['CloseParen'] = 35] = 'CloseParen';
terminalKindCABI[terminalKindCABI['Colon'] = 36] = 'Colon';
terminalKindCABI[terminalKindCABI['ColonEqual'] = 37] = 'ColonEqual';
terminalKindCABI[terminalKindCABI['Comma'] = 38] = 'Comma';
terminalKindCABI[terminalKindCABI['ConstantKeyword'] = 39] = 'ConstantKeyword';
terminalKindCABI[terminalKindCABI['ConstructorKeyword'] = 40] = 'ConstructorKeyword';
terminalKindCABI[terminalKindCABI['ContinueKeyword'] = 41] = 'ContinueKeyword';
terminalKindCABI[terminalKindCABI['ContractKeyword'] = 42] = 'ContractKeyword';
terminalKindCABI[terminalKindCABI['CopyOfKeyword'] = 43] = 'CopyOfKeyword';
terminalKindCABI[terminalKindCABI['DaysKeyword'] = 44] = 'DaysKeyword';
terminalKindCABI[terminalKindCABI['DecimalLiteral'] = 45] = 'DecimalLiteral';
terminalKindCABI[terminalKindCABI['DefaultKeyword'] = 46] = 'DefaultKeyword';
terminalKindCABI[terminalKindCABI['DefineKeyword'] = 47] = 'DefineKeyword';
terminalKindCABI[terminalKindCABI['DeleteKeyword'] = 48] = 'DeleteKeyword';
terminalKindCABI[terminalKindCABI['DoKeyword'] = 49] = 'DoKeyword';
terminalKindCABI[terminalKindCABI['DoubleQuotedHexStringLiteral'] = 50] = 'DoubleQuotedHexStringLiteral';
terminalKindCABI[terminalKindCABI['DoubleQuotedStringLiteral'] = 51] = 'DoubleQuotedStringLiteral';
terminalKindCABI[terminalKindCABI['DoubleQuotedUnicodeStringLiteral'] = 52] = 'DoubleQuotedUnicodeStringLiteral';
terminalKindCABI[terminalKindCABI['DoubleQuotedVersionLiteral'] = 53] = 'DoubleQuotedVersionLiteral';
terminalKindCABI[terminalKindCABI['ElseKeyword'] = 54] = 'ElseKeyword';
terminalKindCABI[terminalKindCABI['EmitKeyword'] = 55] = 'EmitKeyword';
terminalKindCABI[terminalKindCABI['EndOfLine'] = 56] = 'EndOfLine';
terminalKindCABI[terminalKindCABI['EnumKeyword'] = 57] = 'EnumKeyword';
terminalKindCABI[terminalKindCABI['Equal'] = 58] = 'Equal';
terminalKindCABI[terminalKindCABI['EqualColon'] = 59] = 'EqualColon';
terminalKindCABI[terminalKindCABI['EqualEqual'] = 60] = 'EqualEqual';
terminalKindCABI[terminalKindCABI['EqualGreaterThan'] = 61] = 'EqualGreaterThan';
terminalKindCABI[terminalKindCABI['ErrorKeyword'] = 62] = 'ErrorKeyword';
terminalKindCABI[terminalKindCABI['EtherKeyword'] = 63] = 'EtherKeyword';
terminalKindCABI[terminalKindCABI['EventKeyword'] = 64] = 'EventKeyword';
terminalKindCABI[terminalKindCABI['ExperimentalKeyword'] = 65] = 'ExperimentalKeyword';
terminalKindCABI[terminalKindCABI['ExternalKeyword'] = 66] = 'ExternalKeyword';
terminalKindCABI[terminalKindCABI['FallbackKeyword'] = 67] = 'FallbackKeyword';
terminalKindCABI[terminalKindCABI['FalseKeyword'] = 68] = 'FalseKeyword';
terminalKindCABI[terminalKindCABI['FinalKeyword'] = 69] = 'FinalKeyword';
terminalKindCABI[terminalKindCABI['FinneyKeyword'] = 70] = 'FinneyKeyword';
terminalKindCABI[terminalKindCABI['FixedKeyword'] = 71] = 'FixedKeyword';
terminalKindCABI[terminalKindCABI['ForKeyword'] = 72] = 'ForKeyword';
terminalKindCABI[terminalKindCABI['FromKeyword'] = 73] = 'FromKeyword';
terminalKindCABI[terminalKindCABI['FunctionKeyword'] = 74] = 'FunctionKeyword';
terminalKindCABI[terminalKindCABI['GlobalKeyword'] = 75] = 'GlobalKeyword';
terminalKindCABI[terminalKindCABI['GreaterThan'] = 76] = 'GreaterThan';
terminalKindCABI[terminalKindCABI['GreaterThanEqual'] = 77] = 'GreaterThanEqual';
terminalKindCABI[terminalKindCABI['GreaterThanGreaterThan'] = 78] = 'GreaterThanGreaterThan';
terminalKindCABI[terminalKindCABI['GreaterThanGreaterThanEqual'] = 79] = 'GreaterThanGreaterThanEqual';
terminalKindCABI[terminalKindCABI['GreaterThanGreaterThanGreaterThan'] = 80] = 'GreaterThanGreaterThanGreaterThan';
terminalKindCABI[terminalKindCABI['GreaterThanGreaterThanGreaterThanEqual'] = 81] = 'GreaterThanGreaterThanGreaterThanEqual';
terminalKindCABI[terminalKindCABI['GweiKeyword'] = 82] = 'GweiKeyword';
terminalKindCABI[terminalKindCABI['HexKeyword'] = 83] = 'HexKeyword';
terminalKindCABI[terminalKindCABI['HexLiteral'] = 84] = 'HexLiteral';
terminalKindCABI[terminalKindCABI['HoursKeyword'] = 85] = 'HoursKeyword';
terminalKindCABI[terminalKindCABI['Identifier'] = 86] = 'Identifier';
terminalKindCABI[terminalKindCABI['IfKeyword'] = 87] = 'IfKeyword';
terminalKindCABI[terminalKindCABI['ImmutableKeyword'] = 88] = 'ImmutableKeyword';
terminalKindCABI[terminalKindCABI['ImplementsKeyword'] = 89] = 'ImplementsKeyword';
terminalKindCABI[terminalKindCABI['ImportKeyword'] = 90] = 'ImportKeyword';
terminalKindCABI[terminalKindCABI['InKeyword'] = 91] = 'InKeyword';
terminalKindCABI[terminalKindCABI['IndexedKeyword'] = 92] = 'IndexedKeyword';
terminalKindCABI[terminalKindCABI['InlineKeyword'] = 93] = 'InlineKeyword';
terminalKindCABI[terminalKindCABI['IntKeyword'] = 94] = 'IntKeyword';
terminalKindCABI[terminalKindCABI['InterfaceKeyword'] = 95] = 'InterfaceKeyword';
terminalKindCABI[terminalKindCABI['InternalKeyword'] = 96] = 'InternalKeyword';
terminalKindCABI[terminalKindCABI['IsKeyword'] = 97] = 'IsKeyword';
terminalKindCABI[terminalKindCABI['LayoutKeyword'] = 98] = 'LayoutKeyword';
terminalKindCABI[terminalKindCABI['LessThan'] = 99] = 'LessThan';
terminalKindCABI[terminalKindCABI['LessThanEqual'] = 100] = 'LessThanEqual';
terminalKindCABI[terminalKindCABI['LessThanLessThan'] = 101] = 'LessThanLessThan';
terminalKindCABI[terminalKindCABI['LessThanLessThanEqual'] = 102] = 'LessThanLessThanEqual';
terminalKindCABI[terminalKindCABI['LetKeyword'] = 103] = 'LetKeyword';
terminalKindCABI[terminalKindCABI['LibraryKeyword'] = 104] = 'LibraryKeyword';
terminalKindCABI[terminalKindCABI['MacroKeyword'] = 105] = 'MacroKeyword';
terminalKindCABI[terminalKindCABI['MappingKeyword'] = 106] = 'MappingKeyword';
terminalKindCABI[terminalKindCABI['MatchKeyword'] = 107] = 'MatchKeyword';
terminalKindCABI[terminalKindCABI['MemoryKeyword'] = 108] = 'MemoryKeyword';
terminalKindCABI[terminalKindCABI['Minus'] = 109] = 'Minus';
terminalKindCABI[terminalKindCABI['MinusEqual'] = 110] = 'MinusEqual';
terminalKindCABI[terminalKindCABI['MinusGreaterThan'] = 111] = 'MinusGreaterThan';
terminalKindCABI[terminalKindCABI['MinusMinus'] = 112] = 'MinusMinus';
terminalKindCABI[terminalKindCABI['MinutesKeyword'] = 113] = 'MinutesKeyword';
terminalKindCABI[terminalKindCABI['ModifierKeyword'] = 114] = 'ModifierKeyword';
terminalKindCABI[terminalKindCABI['MultiLineComment'] = 115] = 'MultiLineComment';
terminalKindCABI[terminalKindCABI['MultiLineNatSpecComment'] = 116] = 'MultiLineNatSpecComment';
terminalKindCABI[terminalKindCABI['MutableKeyword'] = 117] = 'MutableKeyword';
terminalKindCABI[terminalKindCABI['NewKeyword'] = 118] = 'NewKeyword';
terminalKindCABI[terminalKindCABI['NullKeyword'] = 119] = 'NullKeyword';
terminalKindCABI[terminalKindCABI['OfKeyword'] = 120] = 'OfKeyword';
terminalKindCABI[terminalKindCABI['OpenBrace'] = 121] = 'OpenBrace';
terminalKindCABI[terminalKindCABI['OpenBracket'] = 122] = 'OpenBracket';
terminalKindCABI[terminalKindCABI['OpenParen'] = 123] = 'OpenParen';
terminalKindCABI[terminalKindCABI['OverrideKeyword'] = 124] = 'OverrideKeyword';
terminalKindCABI[terminalKindCABI['PartialKeyword'] = 125] = 'PartialKeyword';
terminalKindCABI[terminalKindCABI['PayableKeyword'] = 126] = 'PayableKeyword';
terminalKindCABI[terminalKindCABI['Percent'] = 127] = 'Percent';
terminalKindCABI[terminalKindCABI['PercentEqual'] = 128] = 'PercentEqual';
terminalKindCABI[terminalKindCABI['Period'] = 129] = 'Period';
terminalKindCABI[terminalKindCABI['Plus'] = 130] = 'Plus';
terminalKindCABI[terminalKindCABI['PlusEqual'] = 131] = 'PlusEqual';
terminalKindCABI[terminalKindCABI['PlusPlus'] = 132] = 'PlusPlus';
terminalKindCABI[terminalKindCABI['PragmaKeyword'] = 133] = 'PragmaKeyword';
terminalKindCABI[terminalKindCABI['PrivateKeyword'] = 134] = 'PrivateKeyword';
terminalKindCABI[terminalKindCABI['PromiseKeyword'] = 135] = 'PromiseKeyword';
terminalKindCABI[terminalKindCABI['PublicKeyword'] = 136] = 'PublicKeyword';
terminalKindCABI[terminalKindCABI['PureKeyword'] = 137] = 'PureKeyword';
terminalKindCABI[terminalKindCABI['QuestionMark'] = 138] = 'QuestionMark';
terminalKindCABI[terminalKindCABI['ReceiveKeyword'] = 139] = 'ReceiveKeyword';
terminalKindCABI[terminalKindCABI['ReferenceKeyword'] = 140] = 'ReferenceKeyword';
terminalKindCABI[terminalKindCABI['RelocatableKeyword'] = 141] = 'RelocatableKeyword';
terminalKindCABI[terminalKindCABI['ReturnKeyword'] = 142] = 'ReturnKeyword';
terminalKindCABI[terminalKindCABI['ReturnsKeyword'] = 143] = 'ReturnsKeyword';
terminalKindCABI[terminalKindCABI['RevertKeyword'] = 144] = 'RevertKeyword';
terminalKindCABI[terminalKindCABI['SealedKeyword'] = 145] = 'SealedKeyword';
terminalKindCABI[terminalKindCABI['SecondsKeyword'] = 146] = 'SecondsKeyword';
terminalKindCABI[terminalKindCABI['Semicolon'] = 147] = 'Semicolon';
terminalKindCABI[terminalKindCABI['SingleLineComment'] = 148] = 'SingleLineComment';
terminalKindCABI[terminalKindCABI['SingleLineNatSpecComment'] = 149] = 'SingleLineNatSpecComment';
terminalKindCABI[terminalKindCABI['SingleQuotedHexStringLiteral'] = 150] = 'SingleQuotedHexStringLiteral';
terminalKindCABI[terminalKindCABI['SingleQuotedStringLiteral'] = 151] = 'SingleQuotedStringLiteral';
terminalKindCABI[terminalKindCABI['SingleQuotedUnicodeStringLiteral'] = 152] = 'SingleQuotedUnicodeStringLiteral';
terminalKindCABI[terminalKindCABI['SingleQuotedVersionLiteral'] = 153] = 'SingleQuotedVersionLiteral';
terminalKindCABI[terminalKindCABI['SizeOfKeyword'] = 154] = 'SizeOfKeyword';
terminalKindCABI[terminalKindCABI['Slash'] = 155] = 'Slash';
terminalKindCABI[terminalKindCABI['SlashEqual'] = 156] = 'SlashEqual';
terminalKindCABI[terminalKindCABI['SolidityKeyword'] = 157] = 'SolidityKeyword';
terminalKindCABI[terminalKindCABI['StaticKeyword'] = 158] = 'StaticKeyword';
terminalKindCABI[terminalKindCABI['StorageKeyword'] = 159] = 'StorageKeyword';
terminalKindCABI[terminalKindCABI['StringKeyword'] = 160] = 'StringKeyword';
terminalKindCABI[terminalKindCABI['StructKeyword'] = 161] = 'StructKeyword';
terminalKindCABI[terminalKindCABI['SuperKeyword'] = 162] = 'SuperKeyword';
terminalKindCABI[terminalKindCABI['SupportsKeyword'] = 163] = 'SupportsKeyword';
terminalKindCABI[terminalKindCABI['SwitchKeyword'] = 164] = 'SwitchKeyword';
terminalKindCABI[terminalKindCABI['SzaboKeyword'] = 165] = 'SzaboKeyword';
terminalKindCABI[terminalKindCABI['ThisKeyword'] = 166] = 'ThisKeyword';
terminalKindCABI[terminalKindCABI['ThrowKeyword'] = 167] = 'ThrowKeyword';
terminalKindCABI[terminalKindCABI['Tilde'] = 168] = 'Tilde';
terminalKindCABI[terminalKindCABI['TransientKeyword'] = 169] = 'TransientKeyword';
terminalKindCABI[terminalKindCABI['TrueKeyword'] = 170] = 'TrueKeyword';
terminalKindCABI[terminalKindCABI['TryKeyword'] = 171] = 'TryKeyword';
terminalKindCABI[terminalKindCABI['TypeDefKeyword'] = 172] = 'TypeDefKeyword';
terminalKindCABI[terminalKindCABI['TypeKeyword'] = 173] = 'TypeKeyword';
terminalKindCABI[terminalKindCABI['TypeOfKeyword'] = 174] = 'TypeOfKeyword';
terminalKindCABI[terminalKindCABI['UfixedKeyword'] = 175] = 'UfixedKeyword';
terminalKindCABI[terminalKindCABI['UintKeyword'] = 176] = 'UintKeyword';
terminalKindCABI[terminalKindCABI['UncheckedKeyword'] = 177] = 'UncheckedKeyword';
terminalKindCABI[terminalKindCABI['UsingKeyword'] = 178] = 'UsingKeyword';
terminalKindCABI[terminalKindCABI['VarKeyword'] = 179] = 'VarKeyword';
terminalKindCABI[terminalKindCABI['VersionSpecifier'] = 180] = 'VersionSpecifier';
terminalKindCABI[terminalKindCABI['ViewKeyword'] = 181] = 'ViewKeyword';
terminalKindCABI[terminalKindCABI['VirtualKeyword'] = 182] = 'VirtualKeyword';
terminalKindCABI[terminalKindCABI['WeeksKeyword'] = 183] = 'WeeksKeyword';
terminalKindCABI[terminalKindCABI['WeiKeyword'] = 184] = 'WeiKeyword';
terminalKindCABI[terminalKindCABI['WhileKeyword'] = 185] = 'WhileKeyword';
terminalKindCABI[terminalKindCABI['Whitespace'] = 186] = 'Whitespace';
terminalKindCABI[terminalKindCABI['YearsKeyword'] = 187] = 'YearsKeyword';
terminalKindCABI[terminalKindCABI['YulAbstractKeyword'] = 188] = 'YulAbstractKeyword';
terminalKindCABI[terminalKindCABI['YulAfterKeyword'] = 189] = 'YulAfterKeyword';
terminalKindCABI[terminalKindCABI['YulAliasKeyword'] = 190] = 'YulAliasKeyword';
terminalKindCABI[terminalKindCABI['YulAnonymousKeyword'] = 191] = 'YulAnonymousKeyword';
terminalKindCABI[terminalKindCABI['YulApplyKeyword'] = 192] = 'YulApplyKeyword';
terminalKindCABI[terminalKindCABI['YulAsKeyword'] = 193] = 'YulAsKeyword';
terminalKindCABI[terminalKindCABI['YulAssemblyKeyword'] = 194] = 'YulAssemblyKeyword';
terminalKindCABI[terminalKindCABI['YulAutoKeyword'] = 195] = 'YulAutoKeyword';
terminalKindCABI[terminalKindCABI['YulBoolKeyword'] = 196] = 'YulBoolKeyword';
terminalKindCABI[terminalKindCABI['YulBreakKeyword'] = 197] = 'YulBreakKeyword';
terminalKindCABI[terminalKindCABI['YulBytesKeyword'] = 198] = 'YulBytesKeyword';
terminalKindCABI[terminalKindCABI['YulCallDataKeyword'] = 199] = 'YulCallDataKeyword';
terminalKindCABI[terminalKindCABI['YulCaseKeyword'] = 200] = 'YulCaseKeyword';
terminalKindCABI[terminalKindCABI['YulCatchKeyword'] = 201] = 'YulCatchKeyword';
terminalKindCABI[terminalKindCABI['YulConstantKeyword'] = 202] = 'YulConstantKeyword';
terminalKindCABI[terminalKindCABI['YulConstructorKeyword'] = 203] = 'YulConstructorKeyword';
terminalKindCABI[terminalKindCABI['YulContinueKeyword'] = 204] = 'YulContinueKeyword';
terminalKindCABI[terminalKindCABI['YulContractKeyword'] = 205] = 'YulContractKeyword';
terminalKindCABI[terminalKindCABI['YulCopyOfKeyword'] = 206] = 'YulCopyOfKeyword';
terminalKindCABI[terminalKindCABI['YulDaysKeyword'] = 207] = 'YulDaysKeyword';
terminalKindCABI[terminalKindCABI['YulDecimalLiteral'] = 208] = 'YulDecimalLiteral';
terminalKindCABI[terminalKindCABI['YulDefaultKeyword'] = 209] = 'YulDefaultKeyword';
terminalKindCABI[terminalKindCABI['YulDefineKeyword'] = 210] = 'YulDefineKeyword';
terminalKindCABI[terminalKindCABI['YulDeleteKeyword'] = 211] = 'YulDeleteKeyword';
terminalKindCABI[terminalKindCABI['YulDoKeyword'] = 212] = 'YulDoKeyword';
terminalKindCABI[terminalKindCABI['YulElseKeyword'] = 213] = 'YulElseKeyword';
terminalKindCABI[terminalKindCABI['YulEmitKeyword'] = 214] = 'YulEmitKeyword';
terminalKindCABI[terminalKindCABI['YulEnumKeyword'] = 215] = 'YulEnumKeyword';
terminalKindCABI[terminalKindCABI['YulEtherKeyword'] = 216] = 'YulEtherKeyword';
terminalKindCABI[terminalKindCABI['YulEventKeyword'] = 217] = 'YulEventKeyword';
terminalKindCABI[terminalKindCABI['YulExternalKeyword'] = 218] = 'YulExternalKeyword';
terminalKindCABI[terminalKindCABI['YulFallbackKeyword'] = 219] = 'YulFallbackKeyword';
terminalKindCABI[terminalKindCABI['YulFalseKeyword'] = 220] = 'YulFalseKeyword';
terminalKindCABI[terminalKindCABI['YulFinalKeyword'] = 221] = 'YulFinalKeyword';
terminalKindCABI[terminalKindCABI['YulFinneyKeyword'] = 222] = 'YulFinneyKeyword';
terminalKindCABI[terminalKindCABI['YulFixedKeyword'] = 223] = 'YulFixedKeyword';
terminalKindCABI[terminalKindCABI['YulForKeyword'] = 224] = 'YulForKeyword';
terminalKindCABI[terminalKindCABI['YulFunctionKeyword'] = 225] = 'YulFunctionKeyword';
terminalKindCABI[terminalKindCABI['YulGweiKeyword'] = 226] = 'YulGweiKeyword';
terminalKindCABI[terminalKindCABI['YulHexKeyword'] = 227] = 'YulHexKeyword';
terminalKindCABI[terminalKindCABI['YulHexLiteral'] = 228] = 'YulHexLiteral';
terminalKindCABI[terminalKindCABI['YulHoursKeyword'] = 229] = 'YulHoursKeyword';
terminalKindCABI[terminalKindCABI['YulIdentifier'] = 230] = 'YulIdentifier';
terminalKindCABI[terminalKindCABI['YulIfKeyword'] = 231] = 'YulIfKeyword';
terminalKindCABI[terminalKindCABI['YulImmutableKeyword'] = 232] = 'YulImmutableKeyword';
terminalKindCABI[terminalKindCABI['YulImplementsKeyword'] = 233] = 'YulImplementsKeyword';
terminalKindCABI[terminalKindCABI['YulImportKeyword'] = 234] = 'YulImportKeyword';
terminalKindCABI[terminalKindCABI['YulInKeyword'] = 235] = 'YulInKeyword';
terminalKindCABI[terminalKindCABI['YulIndexedKeyword'] = 236] = 'YulIndexedKeyword';
terminalKindCABI[terminalKindCABI['YulInlineKeyword'] = 237] = 'YulInlineKeyword';
terminalKindCABI[terminalKindCABI['YulIntKeyword'] = 238] = 'YulIntKeyword';
terminalKindCABI[terminalKindCABI['YulInterfaceKeyword'] = 239] = 'YulInterfaceKeyword';
terminalKindCABI[terminalKindCABI['YulInternalKeyword'] = 240] = 'YulInternalKeyword';
terminalKindCABI[terminalKindCABI['YulIsKeyword'] = 241] = 'YulIsKeyword';
terminalKindCABI[terminalKindCABI['YulLeaveKeyword'] = 242] = 'YulLeaveKeyword';
terminalKindCABI[terminalKindCABI['YulLetKeyword'] = 243] = 'YulLetKeyword';
terminalKindCABI[terminalKindCABI['YulLibraryKeyword'] = 244] = 'YulLibraryKeyword';
terminalKindCABI[terminalKindCABI['YulMacroKeyword'] = 245] = 'YulMacroKeyword';
terminalKindCABI[terminalKindCABI['YulMappingKeyword'] = 246] = 'YulMappingKeyword';
terminalKindCABI[terminalKindCABI['YulMatchKeyword'] = 247] = 'YulMatchKeyword';
terminalKindCABI[terminalKindCABI['YulMemoryKeyword'] = 248] = 'YulMemoryKeyword';
terminalKindCABI[terminalKindCABI['YulMinutesKeyword'] = 249] = 'YulMinutesKeyword';
terminalKindCABI[terminalKindCABI['YulModifierKeyword'] = 250] = 'YulModifierKeyword';
terminalKindCABI[terminalKindCABI['YulMutableKeyword'] = 251] = 'YulMutableKeyword';
terminalKindCABI[terminalKindCABI['YulNewKeyword'] = 252] = 'YulNewKeyword';
terminalKindCABI[terminalKindCABI['YulNullKeyword'] = 253] = 'YulNullKeyword';
terminalKindCABI[terminalKindCABI['YulOfKeyword'] = 254] = 'YulOfKeyword';
terminalKindCABI[terminalKindCABI['YulOverrideKeyword'] = 255] = 'YulOverrideKeyword';
terminalKindCABI[terminalKindCABI['YulPartialKeyword'] = 256] = 'YulPartialKeyword';
terminalKindCABI[terminalKindCABI['YulPayableKeyword'] = 257] = 'YulPayableKeyword';
terminalKindCABI[terminalKindCABI['YulPragmaKeyword'] = 258] = 'YulPragmaKeyword';
terminalKindCABI[terminalKindCABI['YulPrivateKeyword'] = 259] = 'YulPrivateKeyword';
terminalKindCABI[terminalKindCABI['YulPromiseKeyword'] = 260] = 'YulPromiseKeyword';
terminalKindCABI[terminalKindCABI['YulPublicKeyword'] = 261] = 'YulPublicKeyword';
terminalKindCABI[terminalKindCABI['YulPureKeyword'] = 262] = 'YulPureKeyword';
terminalKindCABI[terminalKindCABI['YulReceiveKeyword'] = 263] = 'YulReceiveKeyword';
terminalKindCABI[terminalKindCABI['YulReferenceKeyword'] = 264] = 'YulReferenceKeyword';
terminalKindCABI[terminalKindCABI['YulRelocatableKeyword'] = 265] = 'YulRelocatableKeyword';
terminalKindCABI[terminalKindCABI['YulReturnsKeyword'] = 266] = 'YulReturnsKeyword';
terminalKindCABI[terminalKindCABI['YulSealedKeyword'] = 267] = 'YulSealedKeyword';
terminalKindCABI[terminalKindCABI['YulSecondsKeyword'] = 268] = 'YulSecondsKeyword';
terminalKindCABI[terminalKindCABI['YulSizeOfKeyword'] = 269] = 'YulSizeOfKeyword';
terminalKindCABI[terminalKindCABI['YulStaticKeyword'] = 270] = 'YulStaticKeyword';
terminalKindCABI[terminalKindCABI['YulStorageKeyword'] = 271] = 'YulStorageKeyword';
terminalKindCABI[terminalKindCABI['YulStringKeyword'] = 272] = 'YulStringKeyword';
terminalKindCABI[terminalKindCABI['YulStructKeyword'] = 273] = 'YulStructKeyword';
terminalKindCABI[terminalKindCABI['YulSuperKeyword'] = 274] = 'YulSuperKeyword';
terminalKindCABI[terminalKindCABI['YulSupportsKeyword'] = 275] = 'YulSupportsKeyword';
terminalKindCABI[terminalKindCABI['YulSwitchKeyword'] = 276] = 'YulSwitchKeyword';
terminalKindCABI[terminalKindCABI['YulSzaboKeyword'] = 277] = 'YulSzaboKeyword';
terminalKindCABI[terminalKindCABI['YulThisKeyword'] = 278] = 'YulThisKeyword';
terminalKindCABI[terminalKindCABI['YulThrowKeyword'] = 279] = 'YulThrowKeyword';
terminalKindCABI[terminalKindCABI['YulTrueKeyword'] = 280] = 'YulTrueKeyword';
terminalKindCABI[terminalKindCABI['YulTryKeyword'] = 281] = 'YulTryKeyword';
terminalKindCABI[terminalKindCABI['YulTypeDefKeyword'] = 282] = 'YulTypeDefKeyword';
terminalKindCABI[terminalKindCABI['YulTypeKeyword'] = 283] = 'YulTypeKeyword';
terminalKindCABI[terminalKindCABI['YulTypeOfKeyword'] = 284] = 'YulTypeOfKeyword';
terminalKindCABI[terminalKindCABI['YulUfixedKeyword'] = 285] = 'YulUfixedKeyword';
terminalKindCABI[terminalKindCABI['YulUintKeyword'] = 286] = 'YulUintKeyword';
terminalKindCABI[terminalKindCABI['YulUncheckedKeyword'] = 287] = 'YulUncheckedKeyword';
terminalKindCABI[terminalKindCABI['YulUsingKeyword'] = 288] = 'YulUsingKeyword';
terminalKindCABI[terminalKindCABI['YulVarKeyword'] = 289] = 'YulVarKeyword';
terminalKindCABI[terminalKindCABI['YulViewKeyword'] = 290] = 'YulViewKeyword';
terminalKindCABI[terminalKindCABI['YulVirtualKeyword'] = 291] = 'YulVirtualKeyword';
terminalKindCABI[terminalKindCABI['YulWeeksKeyword'] = 292] = 'YulWeeksKeyword';
terminalKindCABI[terminalKindCABI['YulWeiKeyword'] = 293] = 'YulWeiKeyword';
terminalKindCABI[terminalKindCABI['YulWhileKeyword'] = 294] = 'YulWhileKeyword';
terminalKindCABI[terminalKindCABI['YulYearsKeyword'] = 295] = 'YulYearsKeyword';

var edgeLabel = {};
edgeLabel['Root'] = 'Root';
edgeLabel['Unrecognized'] = 'Unrecognized';
edgeLabel['Missing'] = 'Missing';
edgeLabel['Item'] = 'Item';
edgeLabel['Variant'] = 'Variant';
edgeLabel['Separator'] = 'Separator';
edgeLabel['Operand'] = 'Operand';
edgeLabel['LeftOperand'] = 'LeftOperand';
edgeLabel['RightOperand'] = 'RightOperand';
edgeLabel['LeadingTrivia'] = 'LeadingTrivia';
edgeLabel['TrailingTrivia'] = 'TrailingTrivia';
edgeLabel['AbicoderKeyword'] = 'AbicoderKeyword';
edgeLabel['AbstractKeyword'] = 'AbstractKeyword';
edgeLabel['AddressKeyword'] = 'AddressKeyword';
edgeLabel['Alias'] = 'Alias';
edgeLabel['AnonymousKeyword'] = 'AnonymousKeyword';
edgeLabel['Arguments'] = 'Arguments';
edgeLabel['AsKeyword'] = 'AsKeyword';
edgeLabel['AssemblyKeyword'] = 'AssemblyKeyword';
edgeLabel['Assignment'] = 'Assignment';
edgeLabel['Asterisk'] = 'Asterisk';
edgeLabel['AtKeyword'] = 'AtKeyword';
edgeLabel['Attributes'] = 'Attributes';
edgeLabel['Block'] = 'Block';
edgeLabel['Body'] = 'Body';
edgeLabel['BreakKeyword'] = 'BreakKeyword';
edgeLabel['CaseKeyword'] = 'CaseKeyword';
edgeLabel['Cases'] = 'Cases';
edgeLabel['CatchClauses'] = 'CatchClauses';
edgeLabel['CatchKeyword'] = 'CatchKeyword';
edgeLabel['Clause'] = 'Clause';
edgeLabel['CloseBrace'] = 'CloseBrace';
edgeLabel['CloseBracket'] = 'CloseBracket';
edgeLabel['CloseParen'] = 'CloseParen';
edgeLabel['Colon'] = 'Colon';
edgeLabel['Condition'] = 'Condition';
edgeLabel['ConstantKeyword'] = 'ConstantKeyword';
edgeLabel['ConstructorKeyword'] = 'ConstructorKeyword';
edgeLabel['ContinueKeyword'] = 'ContinueKeyword';
edgeLabel['ContractKeyword'] = 'ContractKeyword';
edgeLabel['DefaultKeyword'] = 'DefaultKeyword';
edgeLabel['DoKeyword'] = 'DoKeyword';
edgeLabel['Elements'] = 'Elements';
edgeLabel['ElseBranch'] = 'ElseBranch';
edgeLabel['ElseKeyword'] = 'ElseKeyword';
edgeLabel['EmitKeyword'] = 'EmitKeyword';
edgeLabel['End'] = 'End';
edgeLabel['EnumKeyword'] = 'EnumKeyword';
edgeLabel['Equal'] = 'Equal';
edgeLabel['EqualGreaterThan'] = 'EqualGreaterThan';
edgeLabel['Error'] = 'Error';
edgeLabel['ErrorKeyword'] = 'ErrorKeyword';
edgeLabel['Event'] = 'Event';
edgeLabel['EventKeyword'] = 'EventKeyword';
edgeLabel['ExperimentalKeyword'] = 'ExperimentalKeyword';
edgeLabel['Expression'] = 'Expression';
edgeLabel['FallbackKeyword'] = 'FallbackKeyword';
edgeLabel['FalseExpression'] = 'FalseExpression';
edgeLabel['Feature'] = 'Feature';
edgeLabel['Flags'] = 'Flags';
edgeLabel['ForKeyword'] = 'ForKeyword';
edgeLabel['FromKeyword'] = 'FromKeyword';
edgeLabel['FunctionKeyword'] = 'FunctionKeyword';
edgeLabel['GlobalKeyword'] = 'GlobalKeyword';
edgeLabel['Identifier'] = 'Identifier';
edgeLabel['IfKeyword'] = 'IfKeyword';
edgeLabel['ImportKeyword'] = 'ImportKeyword';
edgeLabel['Index'] = 'Index';
edgeLabel['IndexedKeyword'] = 'IndexedKeyword';
edgeLabel['Inheritance'] = 'Inheritance';
edgeLabel['Initialization'] = 'Initialization';
edgeLabel['InterfaceKeyword'] = 'InterfaceKeyword';
edgeLabel['IsKeyword'] = 'IsKeyword';
edgeLabel['Items'] = 'Items';
edgeLabel['Iterator'] = 'Iterator';
edgeLabel['KeyType'] = 'KeyType';
edgeLabel['Label'] = 'Label';
edgeLabel['LayoutKeyword'] = 'LayoutKeyword';
edgeLabel['LeaveKeyword'] = 'LeaveKeyword';
edgeLabel['LetKeyword'] = 'LetKeyword';
edgeLabel['LibraryKeyword'] = 'LibraryKeyword';
edgeLabel['Literal'] = 'Literal';
edgeLabel['MappingKeyword'] = 'MappingKeyword';
edgeLabel['Member'] = 'Member';
edgeLabel['Members'] = 'Members';
edgeLabel['Minus'] = 'Minus';
edgeLabel['MinusGreaterThan'] = 'MinusGreaterThan';
edgeLabel['ModifierKeyword'] = 'ModifierKeyword';
edgeLabel['Name'] = 'Name';
edgeLabel['NewKeyword'] = 'NewKeyword';
edgeLabel['OpenBrace'] = 'OpenBrace';
edgeLabel['OpenBracket'] = 'OpenBracket';
edgeLabel['OpenParen'] = 'OpenParen';
edgeLabel['Operator'] = 'Operator';
edgeLabel['Options'] = 'Options';
edgeLabel['Overridden'] = 'Overridden';
edgeLabel['OverrideKeyword'] = 'OverrideKeyword';
edgeLabel['Parameters'] = 'Parameters';
edgeLabel['Path'] = 'Path';
edgeLabel['Paths'] = 'Paths';
edgeLabel['PayableKeyword'] = 'PayableKeyword';
edgeLabel['Period'] = 'Period';
edgeLabel['Pragma'] = 'Pragma';
edgeLabel['PragmaKeyword'] = 'PragmaKeyword';
edgeLabel['QuestionMark'] = 'QuestionMark';
edgeLabel['ReceiveKeyword'] = 'ReceiveKeyword';
edgeLabel['ReturnKeyword'] = 'ReturnKeyword';
edgeLabel['Returns'] = 'Returns';
edgeLabel['ReturnsKeyword'] = 'ReturnsKeyword';
edgeLabel['RevertKeyword'] = 'RevertKeyword';
edgeLabel['Semicolon'] = 'Semicolon';
edgeLabel['Sets'] = 'Sets';
edgeLabel['SolidityKeyword'] = 'SolidityKeyword';
edgeLabel['Specifiers'] = 'Specifiers';
edgeLabel['Start'] = 'Start';
edgeLabel['Statements'] = 'Statements';
edgeLabel['StorageLocation'] = 'StorageLocation';
edgeLabel['StructKeyword'] = 'StructKeyword';
edgeLabel['SwitchKeyword'] = 'SwitchKeyword';
edgeLabel['Symbols'] = 'Symbols';
edgeLabel['Target'] = 'Target';
edgeLabel['ThrowKeyword'] = 'ThrowKeyword';
edgeLabel['TrueExpression'] = 'TrueExpression';
edgeLabel['TryKeyword'] = 'TryKeyword';
edgeLabel['TypeKeyword'] = 'TypeKeyword';
edgeLabel['TypeName'] = 'TypeName';
edgeLabel['Types'] = 'Types';
edgeLabel['UncheckedKeyword'] = 'UncheckedKeyword';
edgeLabel['Unit'] = 'Unit';
edgeLabel['UsingKeyword'] = 'UsingKeyword';
edgeLabel['Value'] = 'Value';
edgeLabel['ValueType'] = 'ValueType';
edgeLabel['VarKeyword'] = 'VarKeyword';
edgeLabel['Variable'] = 'Variable';
edgeLabel['VariableType'] = 'VariableType';
edgeLabel['Variables'] = 'Variables';
edgeLabel['Version'] = 'Version';
edgeLabel['WhileKeyword'] = 'WhileKeyword';

var edgeLabelCABI = {};
edgeLabelCABI[edgeLabelCABI['Root'] = 0] = 'Root';
edgeLabelCABI[edgeLabelCABI['Unrecognized'] = 1] = 'Unrecognized';
edgeLabelCABI[edgeLabelCABI['Missing'] = 2] = 'Missing';
edgeLabelCABI[edgeLabelCABI['Item'] = 3] = 'Item';
edgeLabelCABI[edgeLabelCABI['Variant'] = 4] = 'Variant';
edgeLabelCABI[edgeLabelCABI['Separator'] = 5] = 'Separator';
edgeLabelCABI[edgeLabelCABI['Operand'] = 6] = 'Operand';
edgeLabelCABI[edgeLabelCABI['LeftOperand'] = 7] = 'LeftOperand';
edgeLabelCABI[edgeLabelCABI['RightOperand'] = 8] = 'RightOperand';
edgeLabelCABI[edgeLabelCABI['LeadingTrivia'] = 9] = 'LeadingTrivia';
edgeLabelCABI[edgeLabelCABI['TrailingTrivia'] = 10] = 'TrailingTrivia';
edgeLabelCABI[edgeLabelCABI['AbicoderKeyword'] = 11] = 'AbicoderKeyword';
edgeLabelCABI[edgeLabelCABI['AbstractKeyword'] = 12] = 'AbstractKeyword';
edgeLabelCABI[edgeLabelCABI['AddressKeyword'] = 13] = 'AddressKeyword';
edgeLabelCABI[edgeLabelCABI['Alias'] = 14] = 'Alias';
edgeLabelCABI[edgeLabelCABI['AnonymousKeyword'] = 15] = 'AnonymousKeyword';
edgeLabelCABI[edgeLabelCABI['Arguments'] = 16] = 'Arguments';
edgeLabelCABI[edgeLabelCABI['AsKeyword'] = 17] = 'AsKeyword';
edgeLabelCABI[edgeLabelCABI['AssemblyKeyword'] = 18] = 'AssemblyKeyword';
edgeLabelCABI[edgeLabelCABI['Assignment'] = 19] = 'Assignment';
edgeLabelCABI[edgeLabelCABI['Asterisk'] = 20] = 'Asterisk';
edgeLabelCABI[edgeLabelCABI['AtKeyword'] = 21] = 'AtKeyword';
edgeLabelCABI[edgeLabelCABI['Attributes'] = 22] = 'Attributes';
edgeLabelCABI[edgeLabelCABI['Block'] = 23] = 'Block';
edgeLabelCABI[edgeLabelCABI['Body'] = 24] = 'Body';
edgeLabelCABI[edgeLabelCABI['BreakKeyword'] = 25] = 'BreakKeyword';
edgeLabelCABI[edgeLabelCABI['CaseKeyword'] = 26] = 'CaseKeyword';
edgeLabelCABI[edgeLabelCABI['Cases'] = 27] = 'Cases';
edgeLabelCABI[edgeLabelCABI['CatchClauses'] = 28] = 'CatchClauses';
edgeLabelCABI[edgeLabelCABI['CatchKeyword'] = 29] = 'CatchKeyword';
edgeLabelCABI[edgeLabelCABI['Clause'] = 30] = 'Clause';
edgeLabelCABI[edgeLabelCABI['CloseBrace'] = 31] = 'CloseBrace';
edgeLabelCABI[edgeLabelCABI['CloseBracket'] = 32] = 'CloseBracket';
edgeLabelCABI[edgeLabelCABI['CloseParen'] = 33] = 'CloseParen';
edgeLabelCABI[edgeLabelCABI['Colon'] = 34] = 'Colon';
edgeLabelCABI[edgeLabelCABI['Condition'] = 35] = 'Condition';
edgeLabelCABI[edgeLabelCABI['ConstantKeyword'] = 36] = 'ConstantKeyword';
edgeLabelCABI[edgeLabelCABI['ConstructorKeyword'] = 37] = 'ConstructorKeyword';
edgeLabelCABI[edgeLabelCABI['ContinueKeyword'] = 38] = 'ContinueKeyword';
edgeLabelCABI[edgeLabelCABI['ContractKeyword'] = 39] = 'ContractKeyword';
edgeLabelCABI[edgeLabelCABI['DefaultKeyword'] = 40] = 'DefaultKeyword';
edgeLabelCABI[edgeLabelCABI['DoKeyword'] = 41] = 'DoKeyword';
edgeLabelCABI[edgeLabelCABI['Elements'] = 42] = 'Elements';
edgeLabelCABI[edgeLabelCABI['ElseBranch'] = 43] = 'ElseBranch';
edgeLabelCABI[edgeLabelCABI['ElseKeyword'] = 44] = 'ElseKeyword';
edgeLabelCABI[edgeLabelCABI['EmitKeyword'] = 45] = 'EmitKeyword';
edgeLabelCABI[edgeLabelCABI['End'] = 46] = 'End';
edgeLabelCABI[edgeLabelCABI['EnumKeyword'] = 47] = 'EnumKeyword';
edgeLabelCABI[edgeLabelCABI['Equal'] = 48] = 'Equal';
edgeLabelCABI[edgeLabelCABI['EqualGreaterThan'] = 49] = 'EqualGreaterThan';
edgeLabelCABI[edgeLabelCABI['Error'] = 50] = 'Error';
edgeLabelCABI[edgeLabelCABI['ErrorKeyword'] = 51] = 'ErrorKeyword';
edgeLabelCABI[edgeLabelCABI['Event'] = 52] = 'Event';
edgeLabelCABI[edgeLabelCABI['EventKeyword'] = 53] = 'EventKeyword';
edgeLabelCABI[edgeLabelCABI['ExperimentalKeyword'] = 54] = 'ExperimentalKeyword';
edgeLabelCABI[edgeLabelCABI['Expression'] = 55] = 'Expression';
edgeLabelCABI[edgeLabelCABI['FallbackKeyword'] = 56] = 'FallbackKeyword';
edgeLabelCABI[edgeLabelCABI['FalseExpression'] = 57] = 'FalseExpression';
edgeLabelCABI[edgeLabelCABI['Feature'] = 58] = 'Feature';
edgeLabelCABI[edgeLabelCABI['Flags'] = 59] = 'Flags';
edgeLabelCABI[edgeLabelCABI['ForKeyword'] = 60] = 'ForKeyword';
edgeLabelCABI[edgeLabelCABI['FromKeyword'] = 61] = 'FromKeyword';
edgeLabelCABI[edgeLabelCABI['FunctionKeyword'] = 62] = 'FunctionKeyword';
edgeLabelCABI[edgeLabelCABI['GlobalKeyword'] = 63] = 'GlobalKeyword';
edgeLabelCABI[edgeLabelCABI['Identifier'] = 64] = 'Identifier';
edgeLabelCABI[edgeLabelCABI['IfKeyword'] = 65] = 'IfKeyword';
edgeLabelCABI[edgeLabelCABI['ImportKeyword'] = 66] = 'ImportKeyword';
edgeLabelCABI[edgeLabelCABI['Index'] = 67] = 'Index';
edgeLabelCABI[edgeLabelCABI['IndexedKeyword'] = 68] = 'IndexedKeyword';
edgeLabelCABI[edgeLabelCABI['Inheritance'] = 69] = 'Inheritance';
edgeLabelCABI[edgeLabelCABI['Initialization'] = 70] = 'Initialization';
edgeLabelCABI[edgeLabelCABI['InterfaceKeyword'] = 71] = 'InterfaceKeyword';
edgeLabelCABI[edgeLabelCABI['IsKeyword'] = 72] = 'IsKeyword';
edgeLabelCABI[edgeLabelCABI['Items'] = 73] = 'Items';
edgeLabelCABI[edgeLabelCABI['Iterator'] = 74] = 'Iterator';
edgeLabelCABI[edgeLabelCABI['KeyType'] = 75] = 'KeyType';
edgeLabelCABI[edgeLabelCABI['Label'] = 76] = 'Label';
edgeLabelCABI[edgeLabelCABI['LayoutKeyword'] = 77] = 'LayoutKeyword';
edgeLabelCABI[edgeLabelCABI['LeaveKeyword'] = 78] = 'LeaveKeyword';
edgeLabelCABI[edgeLabelCABI['LetKeyword'] = 79] = 'LetKeyword';
edgeLabelCABI[edgeLabelCABI['LibraryKeyword'] = 80] = 'LibraryKeyword';
edgeLabelCABI[edgeLabelCABI['Literal'] = 81] = 'Literal';
edgeLabelCABI[edgeLabelCABI['MappingKeyword'] = 82] = 'MappingKeyword';
edgeLabelCABI[edgeLabelCABI['Member'] = 83] = 'Member';
edgeLabelCABI[edgeLabelCABI['Members'] = 84] = 'Members';
edgeLabelCABI[edgeLabelCABI['Minus'] = 85] = 'Minus';
edgeLabelCABI[edgeLabelCABI['MinusGreaterThan'] = 86] = 'MinusGreaterThan';
edgeLabelCABI[edgeLabelCABI['ModifierKeyword'] = 87] = 'ModifierKeyword';
edgeLabelCABI[edgeLabelCABI['Name'] = 88] = 'Name';
edgeLabelCABI[edgeLabelCABI['NewKeyword'] = 89] = 'NewKeyword';
edgeLabelCABI[edgeLabelCABI['OpenBrace'] = 90] = 'OpenBrace';
edgeLabelCABI[edgeLabelCABI['OpenBracket'] = 91] = 'OpenBracket';
edgeLabelCABI[edgeLabelCABI['OpenParen'] = 92] = 'OpenParen';
edgeLabelCABI[edgeLabelCABI['Operator'] = 93] = 'Operator';
edgeLabelCABI[edgeLabelCABI['Options'] = 94] = 'Options';
edgeLabelCABI[edgeLabelCABI['Overridden'] = 95] = 'Overridden';
edgeLabelCABI[edgeLabelCABI['OverrideKeyword'] = 96] = 'OverrideKeyword';
edgeLabelCABI[edgeLabelCABI['Parameters'] = 97] = 'Parameters';
edgeLabelCABI[edgeLabelCABI['Path'] = 98] = 'Path';
edgeLabelCABI[edgeLabelCABI['Paths'] = 99] = 'Paths';
edgeLabelCABI[edgeLabelCABI['PayableKeyword'] = 100] = 'PayableKeyword';
edgeLabelCABI[edgeLabelCABI['Period'] = 101] = 'Period';
edgeLabelCABI[edgeLabelCABI['Pragma'] = 102] = 'Pragma';
edgeLabelCABI[edgeLabelCABI['PragmaKeyword'] = 103] = 'PragmaKeyword';
edgeLabelCABI[edgeLabelCABI['QuestionMark'] = 104] = 'QuestionMark';
edgeLabelCABI[edgeLabelCABI['ReceiveKeyword'] = 105] = 'ReceiveKeyword';
edgeLabelCABI[edgeLabelCABI['ReturnKeyword'] = 106] = 'ReturnKeyword';
edgeLabelCABI[edgeLabelCABI['Returns'] = 107] = 'Returns';
edgeLabelCABI[edgeLabelCABI['ReturnsKeyword'] = 108] = 'ReturnsKeyword';
edgeLabelCABI[edgeLabelCABI['RevertKeyword'] = 109] = 'RevertKeyword';
edgeLabelCABI[edgeLabelCABI['Semicolon'] = 110] = 'Semicolon';
edgeLabelCABI[edgeLabelCABI['Sets'] = 111] = 'Sets';
edgeLabelCABI[edgeLabelCABI['SolidityKeyword'] = 112] = 'SolidityKeyword';
edgeLabelCABI[edgeLabelCABI['Specifiers'] = 113] = 'Specifiers';
edgeLabelCABI[edgeLabelCABI['Start'] = 114] = 'Start';
edgeLabelCABI[edgeLabelCABI['Statements'] = 115] = 'Statements';
edgeLabelCABI[edgeLabelCABI['StorageLocation'] = 116] = 'StorageLocation';
edgeLabelCABI[edgeLabelCABI['StructKeyword'] = 117] = 'StructKeyword';
edgeLabelCABI[edgeLabelCABI['SwitchKeyword'] = 118] = 'SwitchKeyword';
edgeLabelCABI[edgeLabelCABI['Symbols'] = 119] = 'Symbols';
edgeLabelCABI[edgeLabelCABI['Target'] = 120] = 'Target';
edgeLabelCABI[edgeLabelCABI['ThrowKeyword'] = 121] = 'ThrowKeyword';
edgeLabelCABI[edgeLabelCABI['TrueExpression'] = 122] = 'TrueExpression';
edgeLabelCABI[edgeLabelCABI['TryKeyword'] = 123] = 'TryKeyword';
edgeLabelCABI[edgeLabelCABI['TypeKeyword'] = 124] = 'TypeKeyword';
edgeLabelCABI[edgeLabelCABI['TypeName'] = 125] = 'TypeName';
edgeLabelCABI[edgeLabelCABI['Types'] = 126] = 'Types';
edgeLabelCABI[edgeLabelCABI['UncheckedKeyword'] = 127] = 'UncheckedKeyword';
edgeLabelCABI[edgeLabelCABI['Unit'] = 128] = 'Unit';
edgeLabelCABI[edgeLabelCABI['UsingKeyword'] = 129] = 'UsingKeyword';
edgeLabelCABI[edgeLabelCABI['Value'] = 130] = 'Value';
edgeLabelCABI[edgeLabelCABI['ValueType'] = 131] = 'ValueType';
edgeLabelCABI[edgeLabelCABI['VarKeyword'] = 132] = 'VarKeyword';
edgeLabelCABI[edgeLabelCABI['Variable'] = 133] = 'Variable';
edgeLabelCABI[edgeLabelCABI['VariableType'] = 134] = 'VariableType';
edgeLabelCABI[edgeLabelCABI['Variables'] = 135] = 'Variables';
edgeLabelCABI[edgeLabelCABI['Version'] = 136] = 'Version';
edgeLabelCABI[edgeLabelCABI['WhileKeyword'] = 137] = 'WhileKeyword';

var NodeType= {};

NodeType['NonterminalNode'] = 'NonterminalNode';

Object.defineProperty(NonterminalNode.prototype, "type", {
  get: function() { return NodeType['NonterminalNode']; }
});

NonterminalNode.prototype.asNonterminalNode= function() { return this; };
NonterminalNode.prototype.isNonterminalNode= function() { return true; };


NonterminalNode.prototype.asTerminalNode= function() { return undefined; };
NonterminalNode.prototype.isTerminalNode= function() { return false; };


NodeType['TerminalNode'] = 'TerminalNode';

Object.defineProperty(TerminalNode.prototype, "type", {
  get: function() { return NodeType['TerminalNode']; }
});

TerminalNode.prototype.asTerminalNode= function() { return this; };
TerminalNode.prototype.isTerminalNode= function() { return true; };


TerminalNode.prototype.asNonterminalNode= function() { return undefined; };
TerminalNode.prototype.isNonterminalNode= function() { return false; };


let astStaticSelectorsSequence;

class Selectors{
  constructor () {
    throw new Error('"Selectors" resource does not define a constructor');
  }
}

Selectors.sequence = function sequence(arg0) {
  var handle1 = arg0[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = astStaticSelectorsSequence(handle0);
  let variant10;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr9 = dataView(memory0).getInt32(ret + 4, true);
    var len9 = dataView(memory0).getInt32(ret + 8, true);
    var result9 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr9, len9));
    variant10= {
      tag: 'err',
      val: result9
    };
  } else {
    var len8 = dataView(memory0).getInt32(ret + 8, true);
    var base8 = dataView(memory0).getInt32(ret + 4, true);
    var result8 = [];
    for (let i = 0; i < len8; i++) {
      const base = base8 + i * 12;
      let variant7;
      if (dataView(memory0).getUint8(base + 0, true)) {
        let variant6;
        switch (dataView(memory0).getUint8(base + 4, true)) {
          case 0: {
            var handle3 = dataView(memory0).getInt32(base + 8, true);
            var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
            Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
            finalizationRegistry4.register(rsc2, handle3, rsc2);
            Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
              finalizationRegistry4.unregister(rsc2);
              rscTableRemove(handleTable4, handle3);
              rsc2[symbolDispose] = emptyFunc;
              rsc2[symbolRscHandle] = undefined;
              exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
            }});
            variant6 = rsc2;
            break;
          }
          case 1: {
            var handle5 = dataView(memory0).getInt32(base + 8, true);
            var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
            Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
            finalizationRegistry5.register(rsc4, handle5, rsc4);
            Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
              finalizationRegistry5.unregister(rsc4);
              rscTableRemove(handleTable5, handle5);
              rsc4[symbolDispose] = emptyFunc;
              rsc4[symbolRscHandle] = undefined;
              exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
            }});
            variant6 = rsc4;
            break;
          }
        }
        variant7 = variant6;
      } else {
        variant7 = undefined;
      }
      result8.push(variant7);
    }
    variant10= {
      tag: 'ok',
      val: result8
    };
  }
  const retVal = variant10;
  postReturn4(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
let astStaticSelectorsChoice;

Selectors.choice = function choice(arg0) {
  var handle1 = arg0[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = astStaticSelectorsChoice(handle0);
  let variant8;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr7 = dataView(memory0).getInt32(ret + 4, true);
    var len7 = dataView(memory0).getInt32(ret + 8, true);
    var result7 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr7, len7));
    variant8= {
      tag: 'err',
      val: result7
    };
  } else {
    let variant6;
    switch (dataView(memory0).getUint8(ret + 4, true)) {
      case 0: {
        var handle3 = dataView(memory0).getInt32(ret + 8, true);
        var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
        Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
        finalizationRegistry4.register(rsc2, handle3, rsc2);
        Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
          finalizationRegistry4.unregister(rsc2);
          rscTableRemove(handleTable4, handle3);
          rsc2[symbolDispose] = emptyFunc;
          rsc2[symbolRscHandle] = undefined;
          exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc2;
        break;
      }
      case 1: {
        var handle5 = dataView(memory0).getInt32(ret + 8, true);
        var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
        Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
        finalizationRegistry5.register(rsc4, handle5, rsc4);
        Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
          finalizationRegistry5.unregister(rsc4);
          rscTableRemove(handleTable5, handle5);
          rsc4[symbolDispose] = emptyFunc;
          rsc4[symbolRscHandle] = undefined;
          exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
        }});
        variant6 = rsc4;
        break;
      }
    }
    variant8= {
      tag: 'ok',
      val: variant6
    };
  }
  const retVal = variant8;
  postReturn2(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
let astStaticSelectorsRepeated;

Selectors.repeated = function repeated(arg0) {
  var handle1 = arg0[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = astStaticSelectorsRepeated(handle0);
  let variant9;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr8 = dataView(memory0).getInt32(ret + 4, true);
    var len8 = dataView(memory0).getInt32(ret + 8, true);
    var result8 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr8, len8));
    variant9= {
      tag: 'err',
      val: result8
    };
  } else {
    var len7 = dataView(memory0).getInt32(ret + 8, true);
    var base7 = dataView(memory0).getInt32(ret + 4, true);
    var result7 = [];
    for (let i = 0; i < len7; i++) {
      const base = base7 + i * 8;
      let variant6;
      switch (dataView(memory0).getUint8(base + 0, true)) {
        case 0: {
          var handle3 = dataView(memory0).getInt32(base + 4, true);
          var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
          Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
          finalizationRegistry4.register(rsc2, handle3, rsc2);
          Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
            finalizationRegistry4.unregister(rsc2);
            rscTableRemove(handleTable4, handle3);
            rsc2[symbolDispose] = emptyFunc;
            rsc2[symbolRscHandle] = undefined;
            exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
          }});
          variant6 = rsc2;
          break;
        }
        case 1: {
          var handle5 = dataView(memory0).getInt32(base + 4, true);
          var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
          Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
          finalizationRegistry5.register(rsc4, handle5, rsc4);
          Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
            finalizationRegistry5.unregister(rsc4);
            rscTableRemove(handleTable5, handle5);
            rsc4[symbolDispose] = emptyFunc;
            rsc4[symbolRscHandle] = undefined;
            exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
          }});
          variant6 = rsc4;
          break;
        }
      }
      result7.push(variant6);
    }
    variant9= {
      tag: 'ok',
      val: result7
    };
  }
  const retVal = variant9;
  postReturn5(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
let astStaticSelectorsSeparated;

Selectors.separated = function separated(arg0) {
  var handle1 = arg0[symbolRscHandle];
  if (!handle1 || (handleTable4[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "NonterminalNode" resource.');
  }
  var handle0 = handleTable4[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = astStaticSelectorsSeparated(handle0);
  let variant10;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr9 = dataView(memory0).getInt32(ret + 4, true);
    var len9 = dataView(memory0).getInt32(ret + 8, true);
    var result9 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr9, len9));
    variant10= {
      tag: 'err',
      val: result9
    };
  } else {
    var len8 = dataView(memory0).getInt32(ret + 8, true);
    var base8 = dataView(memory0).getInt32(ret + 4, true);
    var result8 = [];
    for (let i = 0; i < len8; i++) {
      const base = base8 + i * 8;
      var len7 = dataView(memory0).getInt32(base + 4, true);
      var base7 = dataView(memory0).getInt32(base + 0, true);
      var result7 = [];
      for (let i = 0; i < len7; i++) {
        const base = base7 + i * 8;
        let variant6;
        switch (dataView(memory0).getUint8(base + 0, true)) {
          case 0: {
            var handle3 = dataView(memory0).getInt32(base + 4, true);
            var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
            Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
            finalizationRegistry4.register(rsc2, handle3, rsc2);
            Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
              finalizationRegistry4.unregister(rsc2);
              rscTableRemove(handleTable4, handle3);
              rsc2[symbolDispose] = emptyFunc;
              rsc2[symbolRscHandle] = undefined;
              exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
            }});
            variant6 = rsc2;
            break;
          }
          case 1: {
            var handle5 = dataView(memory0).getInt32(base + 4, true);
            var rsc4 = new.target === TerminalNode ? this : Object.create(TerminalNode.prototype);
            Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
            finalizationRegistry5.register(rsc4, handle5, rsc4);
            Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
              finalizationRegistry5.unregister(rsc4);
              rscTableRemove(handleTable5, handle5);
              rsc4[symbolDispose] = emptyFunc;
              rsc4[symbolRscHandle] = undefined;
              exports0['19'](handleTable5[(handle5 << 1) + 1] & ~T_FLAG);
            }});
            variant6 = rsc4;
            break;
          }
        }
        result7.push(variant6);
      }
      result8.push(result7);
    }
    variant10= {
      tag: 'ok',
      val: result8
    };
  }
  const retVal = variant10;
  postReturn6(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
const handleTable11 = [T_FLAG, 0];
const finalizationRegistry11 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable11, handle);
  exports0['26'](rep);
});

handleTables[11] = handleTable11;
const handleTable12 = [T_FLAG, 0];
const finalizationRegistry12 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable12, handle);
  exports0['27'](rep);
});

handleTables[12] = handleTable12;
let bindingsMethodBindingGraphDefinitionAt;

class BindingGraph{
  constructor () {
    throw new Error('"BindingGraph" resource does not define a constructor');
  }
}

BindingGraph.prototype.definitionAt = function definitionAt(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable11[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "BindingGraph" resource.');
  }
  var handle0 = handleTable11[(handle1 << 1) + 1] & ~T_FLAG;
  var handle3 = arg1[symbolRscHandle];
  if (!handle3 || (handleTable6[(handle3 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle2 = handleTable6[(handle3 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodBindingGraphDefinitionAt(handle0, handle2);
  let variant6;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var handle5 = dataView(memory0).getInt32(ret + 4, true);
    var rsc4 = new.target === Definition ? this : Object.create(Definition.prototype);
    Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
    finalizationRegistry12.register(rsc4, handle5, rsc4);
    Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
      finalizationRegistry12.unregister(rsc4);
      rscTableRemove(handleTable12, handle5);
      rsc4[symbolDispose] = emptyFunc;
      rsc4[symbolRscHandle] = undefined;
      exports0['27'](handleTable12[(handle5 << 1) + 1] & ~T_FLAG);
    }});
    variant6 = rsc4;
  } else {
    variant6 = undefined;
  }
  return variant6;
};
const handleTable13 = [T_FLAG, 0];
const finalizationRegistry13 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable13, handle);
  exports0['28'](rep);
});

handleTables[13] = handleTable13;
let bindingsMethodBindingGraphReferenceAt;

BindingGraph.prototype.referenceAt = function referenceAt(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable11[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "BindingGraph" resource.');
  }
  var handle0 = handleTable11[(handle1 << 1) + 1] & ~T_FLAG;
  var handle3 = arg1[symbolRscHandle];
  if (!handle3 || (handleTable6[(handle3 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle2 = handleTable6[(handle3 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodBindingGraphReferenceAt(handle0, handle2);
  let variant6;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var handle5 = dataView(memory0).getInt32(ret + 4, true);
    var rsc4 = new.target === Reference ? this : Object.create(Reference.prototype);
    Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
    finalizationRegistry13.register(rsc4, handle5, rsc4);
    Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
      finalizationRegistry13.unregister(rsc4);
      rscTableRemove(handleTable13, handle5);
      rsc4[symbolDispose] = emptyFunc;
      rsc4[symbolRscHandle] = undefined;
      exports0['28'](handleTable13[(handle5 << 1) + 1] & ~T_FLAG);
    }});
    variant6 = rsc4;
  } else {
    variant6 = undefined;
  }
  return variant6;
};
let bindingsMethodDefinitionId;

class Definition{
  constructor () {
    throw new Error('"Definition" resource does not define a constructor');
  }
}

Object.defineProperty(Definition.prototype, "id", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable12[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Definition" resource.');
  }
  var handle0 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodDefinitionId(handle0);
  return ret >>> 0;
}});
const handleTable14 = [T_FLAG, 0];
const finalizationRegistry14 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable14, handle);
  exports0['29'](rep);
});

handleTables[14] = handleTable14;
const handleTable15 = [T_FLAG, 0];
const finalizationRegistry15 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable15, handle);
  exports0['30'](rep);
});

handleTables[15] = handleTable15;
let bindingsMethodDefinitionNameLocation;

Object.defineProperty(Definition.prototype, "nameLocation", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable12[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Definition" resource.');
  }
  var handle0 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodDefinitionNameLocation(handle0);
  let variant6;
  switch (dataView(memory0).getUint8(ret + 0, true)) {
    case 0: {
      var handle3 = dataView(memory0).getInt32(ret + 4, true);
      var rsc2 = new.target === UserFileLocation ? this : Object.create(UserFileLocation.prototype);
      Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
      finalizationRegistry14.register(rsc2, handle3, rsc2);
      Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
        finalizationRegistry14.unregister(rsc2);
        rscTableRemove(handleTable14, handle3);
        rsc2[symbolDispose] = emptyFunc;
        rsc2[symbolRscHandle] = undefined;
        exports0['29'](handleTable14[(handle3 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc2;
      break;
    }
    case 1: {
      var handle5 = dataView(memory0).getInt32(ret + 4, true);
      var rsc4 = new.target === BuiltInLocation ? this : Object.create(BuiltInLocation.prototype);
      Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
      finalizationRegistry15.register(rsc4, handle5, rsc4);
      Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
        finalizationRegistry15.unregister(rsc4);
        rscTableRemove(handleTable15, handle5);
        rsc4[symbolDispose] = emptyFunc;
        rsc4[symbolRscHandle] = undefined;
        exports0['30'](handleTable15[(handle5 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc4;
      break;
    }
  }
  return variant6;
}});
let bindingsMethodDefinitionDefiniensLocation;

Object.defineProperty(Definition.prototype, "definiensLocation", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable12[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Definition" resource.');
  }
  var handle0 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodDefinitionDefiniensLocation(handle0);
  let variant6;
  switch (dataView(memory0).getUint8(ret + 0, true)) {
    case 0: {
      var handle3 = dataView(memory0).getInt32(ret + 4, true);
      var rsc2 = new.target === UserFileLocation ? this : Object.create(UserFileLocation.prototype);
      Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
      finalizationRegistry14.register(rsc2, handle3, rsc2);
      Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
        finalizationRegistry14.unregister(rsc2);
        rscTableRemove(handleTable14, handle3);
        rsc2[symbolDispose] = emptyFunc;
        rsc2[symbolRscHandle] = undefined;
        exports0['29'](handleTable14[(handle3 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc2;
      break;
    }
    case 1: {
      var handle5 = dataView(memory0).getInt32(ret + 4, true);
      var rsc4 = new.target === BuiltInLocation ? this : Object.create(BuiltInLocation.prototype);
      Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
      finalizationRegistry15.register(rsc4, handle5, rsc4);
      Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
        finalizationRegistry15.unregister(rsc4);
        rscTableRemove(handleTable15, handle5);
        rsc4[symbolDispose] = emptyFunc;
        rsc4[symbolRscHandle] = undefined;
        exports0['30'](handleTable15[(handle5 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc4;
      break;
    }
  }
  return variant6;
}});
let bindingsMethodDefinitionReferences;

Definition.prototype.references = function references() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable12[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Definition" resource.');
  }
  var handle0 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodDefinitionReferences(handle0);
  var len4 = dataView(memory0).getInt32(ret + 4, true);
  var base4 = dataView(memory0).getInt32(ret + 0, true);
  var result4 = [];
  for (let i = 0; i < len4; i++) {
    const base = base4 + i * 4;
    var handle3 = dataView(memory0).getInt32(base + 0, true);
    var rsc2 = new.target === Reference ? this : Object.create(Reference.prototype);
    Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
    finalizationRegistry13.register(rsc2, handle3, rsc2);
    Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
      finalizationRegistry13.unregister(rsc2);
      rscTableRemove(handleTable13, handle3);
      rsc2[symbolDispose] = emptyFunc;
      rsc2[symbolRscHandle] = undefined;
      exports0['28'](handleTable13[(handle3 << 1) + 1] & ~T_FLAG);
    }});
    result4.push(rsc2);
  }
  const retVal = result4;
  postReturn7(ret);
  return retVal;
};
let bindingsMethodReferenceId;

class Reference{
  constructor () {
    throw new Error('"Reference" resource does not define a constructor');
  }
}

Object.defineProperty(Reference.prototype, "id", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable13[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Reference" resource.');
  }
  var handle0 = handleTable13[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodReferenceId(handle0);
  return ret >>> 0;
}});
let bindingsMethodReferenceLocation;

Object.defineProperty(Reference.prototype, "location", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable13[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Reference" resource.');
  }
  var handle0 = handleTable13[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodReferenceLocation(handle0);
  let variant6;
  switch (dataView(memory0).getUint8(ret + 0, true)) {
    case 0: {
      var handle3 = dataView(memory0).getInt32(ret + 4, true);
      var rsc2 = new.target === UserFileLocation ? this : Object.create(UserFileLocation.prototype);
      Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
      finalizationRegistry14.register(rsc2, handle3, rsc2);
      Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
        finalizationRegistry14.unregister(rsc2);
        rscTableRemove(handleTable14, handle3);
        rsc2[symbolDispose] = emptyFunc;
        rsc2[symbolRscHandle] = undefined;
        exports0['29'](handleTable14[(handle3 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc2;
      break;
    }
    case 1: {
      var handle5 = dataView(memory0).getInt32(ret + 4, true);
      var rsc4 = new.target === BuiltInLocation ? this : Object.create(BuiltInLocation.prototype);
      Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
      finalizationRegistry15.register(rsc4, handle5, rsc4);
      Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
        finalizationRegistry15.unregister(rsc4);
        rscTableRemove(handleTable15, handle5);
        rsc4[symbolDispose] = emptyFunc;
        rsc4[symbolRscHandle] = undefined;
        exports0['30'](handleTable15[(handle5 << 1) + 1] & ~T_FLAG);
      }});
      variant6 = rsc4;
      break;
    }
  }
  return variant6;
}});
let bindingsMethodReferenceDefinitions;

Reference.prototype.definitions = function definitions() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable13[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Reference" resource.');
  }
  var handle0 = handleTable13[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodReferenceDefinitions(handle0);
  var len4 = dataView(memory0).getInt32(ret + 4, true);
  var base4 = dataView(memory0).getInt32(ret + 0, true);
  var result4 = [];
  for (let i = 0; i < len4; i++) {
    const base = base4 + i * 4;
    var handle3 = dataView(memory0).getInt32(base + 0, true);
    var rsc2 = new.target === Definition ? this : Object.create(Definition.prototype);
    Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
    finalizationRegistry12.register(rsc2, handle3, rsc2);
    Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
      finalizationRegistry12.unregister(rsc2);
      rscTableRemove(handleTable12, handle3);
      rsc2[symbolDispose] = emptyFunc;
      rsc2[symbolRscHandle] = undefined;
      exports0['27'](handleTable12[(handle3 << 1) + 1] & ~T_FLAG);
    }});
    result4.push(rsc2);
  }
  const retVal = result4;
  postReturn7(ret);
  return retVal;
};
let bindingsMethodUserFileLocationFileId;

class UserFileLocation{
  constructor () {
    throw new Error('"UserFileLocation" resource does not define a constructor');
  }
}

Object.defineProperty(UserFileLocation.prototype, "fileId", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable14[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "UserFileLocation" resource.');
  }
  var handle0 = handleTable14[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodUserFileLocationFileId(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
}});
let bindingsMethodUserFileLocationCursor;

Object.defineProperty(UserFileLocation.prototype, "cursor", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable14[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "UserFileLocation" resource.');
  }
  var handle0 = handleTable14[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = bindingsMethodUserFileLocationCursor(handle0);
  var handle3 = ret;
  var rsc2 = new.target === Cursor ? this : Object.create(Cursor.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry6.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry6.unregister(rsc2);
    rscTableRemove(handleTable6, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['20'](handleTable6[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
}});
var BindingLocationType= {};

BindingLocationType['UserFileLocation'] = 'UserFileLocation';

Object.defineProperty(UserFileLocation.prototype, "type", {
  get: function() { return BindingLocationType['UserFileLocation']; }
});

UserFileLocation.prototype.asUserFileLocation= function() { return this; };
UserFileLocation.prototype.isUserFileLocation= function() { return true; };


UserFileLocation.prototype.asBuiltInLocation= function() { return undefined; };
UserFileLocation.prototype.isBuiltInLocation= function() { return false; };



class BuiltInLocation{
  constructor () {
    throw new Error('"BuiltInLocation" resource does not define a constructor');
  }
}
BindingLocationType['BuiltInLocation'] = 'BuiltInLocation';

Object.defineProperty(BuiltInLocation.prototype, "type", {
  get: function() { return BindingLocationType['BuiltInLocation']; }
});

BuiltInLocation.prototype.asBuiltInLocation= function() { return this; };
BuiltInLocation.prototype.isBuiltInLocation= function() { return true; };


BuiltInLocation.prototype.asUserFileLocation= function() { return undefined; };
BuiltInLocation.prototype.isUserFileLocation= function() { return false; };


const handleTable16 = [T_FLAG, 0];
const finalizationRegistry16 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable16, handle);
  exports0['31'](rep);
});

handleTables[16] = handleTable16;
let parserStaticParserCreate;

class Parser{
  constructor () {
    throw new Error('"Parser" resource does not define a constructor');
  }
}

Parser.create = function create(arg0) {
  var ptr0 = utf8Encode(arg0, realloc1, memory0);
  var len0 = utf8EncodedLen;
  const ret = parserStaticParserCreate(ptr0, len0);
  let variant4;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr3 = dataView(memory0).getInt32(ret + 4, true);
    var len3 = dataView(memory0).getInt32(ret + 8, true);
    var result3 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    variant4= {
      tag: 'err',
      val: result3
    };
  } else {
    var handle2 = dataView(memory0).getInt32(ret + 4, true);
    var rsc1 = new.target === Parser ? this : Object.create(Parser.prototype);
    Object.defineProperty(rsc1, symbolRscHandle, { writable: true, value: handle2});
    finalizationRegistry16.register(rsc1, handle2, rsc1);
    Object.defineProperty(rsc1, symbolDispose, { writable: true, value: function () {
      finalizationRegistry16.unregister(rsc1);
      rscTableRemove(handleTable16, handle2);
      rsc1[symbolDispose] = emptyFunc;
      rsc1[symbolRscHandle] = undefined;
      exports0['31'](handleTable16[(handle2 << 1) + 1] & ~T_FLAG);
    }});
    variant4= {
      tag: 'ok',
      val: rsc1
    };
  }
  const retVal = variant4;
  postReturn2(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
let parserMethodParserLanguageVersion;

Object.defineProperty(Parser.prototype, "languageVersion", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable16[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Parser" resource.');
  }
  var handle0 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = parserMethodParserLanguageVersion(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
}});
const handleTable17 = [T_FLAG, 0];
const finalizationRegistry17 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable17, handle);
  exports0['32'](rep);
});

handleTables[17] = handleTable17;
let parserMethodParserParseFileContents;

Parser.prototype.parseFileContents = function parseFileContents(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable16[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Parser" resource.');
  }
  var handle0 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
  var ptr2 = utf8Encode(arg1, realloc1, memory0);
  var len2 = utf8EncodedLen;
  const ret = parserMethodParserParseFileContents(handle0, ptr2, len2);
  var handle4 = ret;
  var rsc3 = new.target === ParseOutput ? this : Object.create(ParseOutput.prototype);
  Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
  finalizationRegistry17.register(rsc3, handle4, rsc3);
  Object.defineProperty(rsc3, symbolDispose, { writable: true, value: function () {
    finalizationRegistry17.unregister(rsc3);
    rscTableRemove(handleTable17, handle4);
    rsc3[symbolDispose] = emptyFunc;
    rsc3[symbolRscHandle] = undefined;
    exports0['32'](handleTable17[(handle4 << 1) + 1] & ~T_FLAG);
  }});
  return rsc3;
};
let parserMethodParserParseNonterminal;

Parser.prototype.parseNonterminal = function parseNonterminal(arg1, arg2) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable16[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Parser" resource.');
  }
  var handle0 = handleTable16[(handle1 << 1) + 1] & ~T_FLAG;
  var ptr2 = utf8Encode(arg2, realloc1, memory0);
  var len2 = utf8EncodedLen;
  const ret = parserMethodParserParseNonterminal(handle0, nonterminalKindCABI[arg1], ptr2, len2);
  var handle4 = ret;
  var rsc3 = new.target === ParseOutput ? this : Object.create(ParseOutput.prototype);
  Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
  finalizationRegistry17.register(rsc3, handle4, rsc3);
  Object.defineProperty(rsc3, symbolDispose, { writable: true, value: function () {
    finalizationRegistry17.unregister(rsc3);
    rscTableRemove(handleTable17, handle4);
    rsc3[symbolDispose] = emptyFunc;
    rsc3[symbolRscHandle] = undefined;
    exports0['32'](handleTable17[(handle4 << 1) + 1] & ~T_FLAG);
  }});
  return rsc3;
};
let parserMethodParseOutputTree;

class ParseOutput{
  constructor () {
    throw new Error('"ParseOutput" resource does not define a constructor');
  }
}

Object.defineProperty(ParseOutput.prototype, "tree", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable17[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "ParseOutput" resource.');
  }
  var handle0 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = parserMethodParseOutputTree(handle0);
  var handle3 = ret;
  var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry4.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry4.unregister(rsc2);
    rscTableRemove(handleTable4, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
}});
let parserMethodParseOutputErrors;

ParseOutput.prototype.errors = function errors() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable17[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "ParseOutput" resource.');
  }
  var handle0 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = parserMethodParseOutputErrors(handle0);
  var len3 = dataView(memory0).getInt32(ret + 4, true);
  var base3 = dataView(memory0).getInt32(ret + 0, true);
  var result3 = [];
  for (let i = 0; i < len3; i++) {
    const base = base3 + i * 40;
    var ptr2 = dataView(memory0).getInt32(base + 0, true);
    var len2 = dataView(memory0).getInt32(base + 4, true);
    var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
    result3.push({
      message: result2,
      textRange: {
        start: {
          utf8: dataView(memory0).getInt32(base + 8, true) >>> 0,
          utf16: dataView(memory0).getInt32(base + 12, true) >>> 0,
          line: dataView(memory0).getInt32(base + 16, true) >>> 0,
          column: dataView(memory0).getInt32(base + 20, true) >>> 0,
        },
        end: {
          utf8: dataView(memory0).getInt32(base + 24, true) >>> 0,
          utf16: dataView(memory0).getInt32(base + 28, true) >>> 0,
          line: dataView(memory0).getInt32(base + 32, true) >>> 0,
          column: dataView(memory0).getInt32(base + 36, true) >>> 0,
        },
      },
    });
  }
  const retVal = result3;
  postReturn8(ret);
  return retVal;
};
let parserMethodParseOutputIsValid;

ParseOutput.prototype.isValid = function isValid() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable17[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "ParseOutput" resource.');
  }
  var handle0 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = parserMethodParseOutputIsValid(handle0);
  var bool2 = ret;
  return !!bool2;
};
let parserMethodParseOutputCreateTreeCursor;

ParseOutput.prototype.createTreeCursor = function createTreeCursor() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable17[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "ParseOutput" resource.');
  }
  var handle0 = handleTable17[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = parserMethodParseOutputCreateTreeCursor(handle0);
  var handle3 = ret;
  var rsc2 = new.target === Cursor ? this : Object.create(Cursor.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry6.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry6.unregister(rsc2);
    rscTableRemove(handleTable6, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['20'](handleTable6[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
const handleTable18 = [T_FLAG, 0];
const finalizationRegistry18 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable18, handle);
  exports0['33'](rep);
});

handleTables[18] = handleTable18;
let compilationStaticInternalCompilationBuilderCreate;

class InternalCompilationBuilder{
  constructor () {
    throw new Error('"InternalCompilationBuilder" resource does not define a constructor');
  }
}

InternalCompilationBuilder.create = function create(arg0) {
  var ptr0 = utf8Encode(arg0, realloc1, memory0);
  var len0 = utf8EncodedLen;
  const ret = compilationStaticInternalCompilationBuilderCreate(ptr0, len0);
  let variant4;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr3 = dataView(memory0).getInt32(ret + 4, true);
    var len3 = dataView(memory0).getInt32(ret + 8, true);
    var result3 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr3, len3));
    variant4= {
      tag: 'err',
      val: result3
    };
  } else {
    var handle2 = dataView(memory0).getInt32(ret + 4, true);
    var rsc1 = new.target === InternalCompilationBuilder ? this : Object.create(InternalCompilationBuilder.prototype);
    Object.defineProperty(rsc1, symbolRscHandle, { writable: true, value: handle2});
    finalizationRegistry18.register(rsc1, handle2, rsc1);
    Object.defineProperty(rsc1, symbolDispose, { writable: true, value: function () {
      finalizationRegistry18.unregister(rsc1);
      rscTableRemove(handleTable18, handle2);
      rsc1[symbolDispose] = emptyFunc;
      rsc1[symbolRscHandle] = undefined;
      exports0['33'](handleTable18[(handle2 << 1) + 1] & ~T_FLAG);
    }});
    variant4= {
      tag: 'ok',
      val: rsc1
    };
  }
  const retVal = variant4;
  postReturn2(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
let compilationMethodInternalCompilationBuilderAddFile;

InternalCompilationBuilder.prototype.addFile = function addFile(arg1, arg2) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable18[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "InternalCompilationBuilder" resource.');
  }
  var handle0 = handleTable18[(handle1 << 1) + 1] & ~T_FLAG;
  var ptr2 = utf8Encode(arg1, realloc1, memory0);
  var len2 = utf8EncodedLen;
  var ptr3 = utf8Encode(arg2, realloc1, memory0);
  var len3 = utf8EncodedLen;
  const ret = compilationMethodInternalCompilationBuilderAddFile(handle0, ptr2, len2, ptr3, len3);
  var len6 = dataView(memory0).getInt32(ret + 4, true);
  var base6 = dataView(memory0).getInt32(ret + 0, true);
  var result6 = [];
  for (let i = 0; i < len6; i++) {
    const base = base6 + i * 4;
    var handle5 = dataView(memory0).getInt32(base + 0, true);
    var rsc4 = new.target === Cursor ? this : Object.create(Cursor.prototype);
    Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
    finalizationRegistry6.register(rsc4, handle5, rsc4);
    Object.defineProperty(rsc4, symbolDispose, { writable: true, value: function () {
      finalizationRegistry6.unregister(rsc4);
      rscTableRemove(handleTable6, handle5);
      rsc4[symbolDispose] = emptyFunc;
      rsc4[symbolRscHandle] = undefined;
      exports0['20'](handleTable6[(handle5 << 1) + 1] & ~T_FLAG);
    }});
    result6.push(rsc4);
  }
  const retVal = {
    importPaths: result6,
  };
  postReturn7(ret);
  return retVal;
};
let compilationMethodInternalCompilationBuilderResolveImport;

InternalCompilationBuilder.prototype.resolveImport = function resolveImport(arg1, arg2, arg3) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable18[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "InternalCompilationBuilder" resource.');
  }
  var handle0 = handleTable18[(handle1 << 1) + 1] & ~T_FLAG;
  var ptr2 = utf8Encode(arg1, realloc1, memory0);
  var len2 = utf8EncodedLen;
  var handle4 = arg2[symbolRscHandle];
  if (!handle4 || (handleTable6[(handle4 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "Cursor" resource.');
  }
  var handle3 = handleTable6[(handle4 << 1) + 1] & ~T_FLAG;
  var ptr5 = utf8Encode(arg3, realloc1, memory0);
  var len5 = utf8EncodedLen;
  const ret = compilationMethodInternalCompilationBuilderResolveImport(handle0, ptr2, len2, handle3, ptr5, len5);
  let variant7;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var ptr6 = dataView(memory0).getInt32(ret + 4, true);
    var len6 = dataView(memory0).getInt32(ret + 8, true);
    var result6 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr6, len6));
    variant7= {
      tag: 'err',
      val: result6
    };
  } else {
    variant7= {
      tag: 'ok',
      val: undefined
    };
  }
  const retVal = variant7;
  postReturn2(ret);
  if (typeof retVal === 'object' && retVal.tag === 'err') {
    throw retVal.val;
  }
  return retVal.val;
};
const handleTable19 = [T_FLAG, 0];
const finalizationRegistry19 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable19, handle);
  exports0['34'](rep);
});

handleTables[19] = handleTable19;
let compilationMethodInternalCompilationBuilderBuild;

InternalCompilationBuilder.prototype.build = function build() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable18[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "InternalCompilationBuilder" resource.');
  }
  var handle0 = handleTable18[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodInternalCompilationBuilderBuild(handle0);
  var handle3 = ret;
  var rsc2 = new.target === CompilationUnit ? this : Object.create(CompilationUnit.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry19.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry19.unregister(rsc2);
    rscTableRemove(handleTable19, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['34'](handleTable19[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let compilationMethodCompilationUnitLanguageVersion;

class CompilationUnit{
  constructor () {
    throw new Error('"CompilationUnit" resource does not define a constructor');
  }
}

Object.defineProperty(CompilationUnit.prototype, "languageVersion", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable19[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "CompilationUnit" resource.');
  }
  var handle0 = handleTable19[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodCompilationUnitLanguageVersion(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
}});
const handleTable20 = [T_FLAG, 0];
const finalizationRegistry20 = finalizationRegistryCreate((handle) => {
  const { rep } = rscTableRemove(handleTable20, handle);
  exports0['35'](rep);
});

handleTables[20] = handleTable20;
let compilationMethodCompilationUnitFiles;

CompilationUnit.prototype.files = function files() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable19[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "CompilationUnit" resource.');
  }
  var handle0 = handleTable19[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodCompilationUnitFiles(handle0);
  var len4 = dataView(memory0).getInt32(ret + 4, true);
  var base4 = dataView(memory0).getInt32(ret + 0, true);
  var result4 = [];
  for (let i = 0; i < len4; i++) {
    const base = base4 + i * 4;
    var handle3 = dataView(memory0).getInt32(base + 0, true);
    var rsc2 = new.target === File ? this : Object.create(File.prototype);
    Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
    finalizationRegistry20.register(rsc2, handle3, rsc2);
    Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
      finalizationRegistry20.unregister(rsc2);
      rscTableRemove(handleTable20, handle3);
      rsc2[symbolDispose] = emptyFunc;
      rsc2[symbolRscHandle] = undefined;
      exports0['35'](handleTable20[(handle3 << 1) + 1] & ~T_FLAG);
    }});
    result4.push(rsc2);
  }
  const retVal = result4;
  postReturn7(ret);
  return retVal;
};
let compilationMethodCompilationUnitFile;

CompilationUnit.prototype.file = function file(arg1) {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable19[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "CompilationUnit" resource.');
  }
  var handle0 = handleTable19[(handle1 << 1) + 1] & ~T_FLAG;
  var ptr2 = utf8Encode(arg1, realloc1, memory0);
  var len2 = utf8EncodedLen;
  const ret = compilationMethodCompilationUnitFile(handle0, ptr2, len2);
  let variant5;
  if (dataView(memory0).getUint8(ret + 0, true)) {
    var handle4 = dataView(memory0).getInt32(ret + 4, true);
    var rsc3 = new.target === File ? this : Object.create(File.prototype);
    Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
    finalizationRegistry20.register(rsc3, handle4, rsc3);
    Object.defineProperty(rsc3, symbolDispose, { writable: true, value: function () {
      finalizationRegistry20.unregister(rsc3);
      rscTableRemove(handleTable20, handle4);
      rsc3[symbolDispose] = emptyFunc;
      rsc3[symbolRscHandle] = undefined;
      exports0['35'](handleTable20[(handle4 << 1) + 1] & ~T_FLAG);
    }});
    variant5 = rsc3;
  } else {
    variant5 = undefined;
  }
  return variant5;
};
let compilationMethodCompilationUnitBindingGraph;

Object.defineProperty(CompilationUnit.prototype, "bindingGraph", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable19[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "CompilationUnit" resource.');
  }
  var handle0 = handleTable19[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodCompilationUnitBindingGraph(handle0);
  var handle3 = ret;
  var rsc2 = new.target === BindingGraph ? this : Object.create(BindingGraph.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry11.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry11.unregister(rsc2);
    rscTableRemove(handleTable11, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['26'](handleTable11[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
}});
let compilationMethodFileId;

class File{
  constructor () {
    throw new Error('"File" resource does not define a constructor');
  }
}

Object.defineProperty(File.prototype, "id", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable20[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "File" resource.');
  }
  var handle0 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodFileId(handle0);
  var ptr2 = dataView(memory0).getInt32(ret + 0, true);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
  const retVal = result2;
  postReturn1(ret);
  return retVal;
}});
let compilationMethodFileTree;

Object.defineProperty(File.prototype, "tree", { get: function() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable20[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "File" resource.');
  }
  var handle0 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodFileTree(handle0);
  var handle3 = ret;
  var rsc2 = new.target === NonterminalNode ? this : Object.create(NonterminalNode.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry4.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry4.unregister(rsc2);
    rscTableRemove(handleTable4, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['18'](handleTable4[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
}});
let compilationMethodFileErrors;

File.prototype.errors = function errors() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable20[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "File" resource.');
  }
  var handle0 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodFileErrors(handle0);
  var len3 = dataView(memory0).getInt32(ret + 4, true);
  var base3 = dataView(memory0).getInt32(ret + 0, true);
  var result3 = [];
  for (let i = 0; i < len3; i++) {
    const base = base3 + i * 40;
    var ptr2 = dataView(memory0).getInt32(base + 0, true);
    var len2 = dataView(memory0).getInt32(base + 4, true);
    var result2 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr2, len2));
    result3.push({
      message: result2,
      textRange: {
        start: {
          utf8: dataView(memory0).getInt32(base + 8, true) >>> 0,
          utf16: dataView(memory0).getInt32(base + 12, true) >>> 0,
          line: dataView(memory0).getInt32(base + 16, true) >>> 0,
          column: dataView(memory0).getInt32(base + 20, true) >>> 0,
        },
        end: {
          utf8: dataView(memory0).getInt32(base + 24, true) >>> 0,
          utf16: dataView(memory0).getInt32(base + 28, true) >>> 0,
          line: dataView(memory0).getInt32(base + 32, true) >>> 0,
          column: dataView(memory0).getInt32(base + 36, true) >>> 0,
        },
      },
    });
  }
  const retVal = result3;
  postReturn8(ret);
  return retVal;
};
let compilationMethodFileCreateTreeCursor;

File.prototype.createTreeCursor = function createTreeCursor() {
  var handle1 = this[symbolRscHandle];
  if (!handle1 || (handleTable20[(handle1 << 1) + 1] & T_FLAG) === 0) {
    throw new TypeError('Resource error: Not a valid "File" resource.');
  }
  var handle0 = handleTable20[(handle1 << 1) + 1] & ~T_FLAG;
  const ret = compilationMethodFileCreateTreeCursor(handle0);
  var handle3 = ret;
  var rsc2 = new.target === Cursor ? this : Object.create(Cursor.prototype);
  Object.defineProperty(rsc2, symbolRscHandle, { writable: true, value: handle3});
  finalizationRegistry6.register(rsc2, handle3, rsc2);
  Object.defineProperty(rsc2, symbolDispose, { writable: true, value: function () {
    finalizationRegistry6.unregister(rsc2);
    rscTableRemove(handleTable6, handle3);
    rsc2[symbolDispose] = emptyFunc;
    rsc2[symbolRscHandle] = undefined;
    exports0['20'](handleTable6[(handle3 << 1) + 1] & ~T_FLAG);
  }});
  return rsc2;
};
let utilsStaticLanguageFactsAllVersions;

class LanguageFacts{
  constructor () {
    throw new Error('"LanguageFacts" resource does not define a constructor');
  }
}

LanguageFacts.allVersions = function allVersions() {
  const ret = utilsStaticLanguageFactsAllVersions();
  var len1 = dataView(memory0).getInt32(ret + 4, true);
  var base1 = dataView(memory0).getInt32(ret + 0, true);
  var result1 = [];
  for (let i = 0; i < len1; i++) {
    const base = base1 + i * 8;
    var ptr0 = dataView(memory0).getInt32(base + 0, true);
    var len0 = dataView(memory0).getInt32(base + 4, true);
    var result0 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr0, len0));
    result1.push(result0);
  }
  const retVal = result1;
  postReturn9(ret);
  return retVal;
};
let utilsStaticLanguageFactsEarliestVersion;

LanguageFacts.earliestVersion = function earliestVersion() {
  const ret = utilsStaticLanguageFactsEarliestVersion();
  var ptr0 = dataView(memory0).getInt32(ret + 0, true);
  var len0 = dataView(memory0).getInt32(ret + 4, true);
  var result0 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr0, len0));
  const retVal = result0;
  postReturn1(ret);
  return retVal;
};
let utilsStaticLanguageFactsLatestVersion;

LanguageFacts.latestVersion = function latestVersion() {
  const ret = utilsStaticLanguageFactsLatestVersion();
  var ptr0 = dataView(memory0).getInt32(ret + 0, true);
  var len0 = dataView(memory0).getInt32(ret + 4, true);
  var result0 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr0, len0));
  const retVal = result0;
  postReturn1(ret);
  return retVal;
};
let utilsStaticLanguageFactsInferLanguageVersions;

LanguageFacts.inferLanguageVersions = function inferLanguageVersions(arg0) {
  var ptr0 = utf8Encode(arg0, realloc1, memory0);
  var len0 = utf8EncodedLen;
  const ret = utilsStaticLanguageFactsInferLanguageVersions(ptr0, len0);
  var len2 = dataView(memory0).getInt32(ret + 4, true);
  var base2 = dataView(memory0).getInt32(ret + 0, true);
  var result2 = [];
  for (let i = 0; i < len2; i++) {
    const base = base2 + i * 8;
    var ptr1 = dataView(memory0).getInt32(base + 0, true);
    var len1 = dataView(memory0).getInt32(base + 4, true);
    var result1 = utf8Decoder.decode(new Uint8Array(memory0.buffer, ptr1, len1));
    result2.push(result1);
  }
  const retVal = result2;
  postReturn9(ret);
  return retVal;
};
function trampoline0(handle) {
  const handleEntry = rscTableRemove(handleTable4, handle);
  if (handleEntry.own) {
    
    exports0['18'](handleEntry.rep);
  }
}
function trampoline1(handle) {
  const handleEntry = rscTableRemove(handleTable5, handle);
  if (handleEntry.own) {
    
    exports0['19'](handleEntry.rep);
  }
}
const trampoline2 = rscTableCreateOwn.bind(null, handleTable7);
function trampoline3(handle) {
  const handleEntry = rscTableRemove(handleTable7, handle);
  if (handleEntry.own) {
    
    exports0['21'](handleEntry.rep);
  }
}
const trampoline4 = rscTableCreateOwn.bind(null, handleTable6);
function trampoline5(handle) {
  const handleEntry = rscTableRemove(handleTable6, handle);
  if (handleEntry.own) {
    
    exports0['20'](handleEntry.rep);
  }
}
const trampoline6 = rscTableCreateOwn.bind(null, handleTable4);
const trampoline7 = rscTableCreateOwn.bind(null, handleTable5);
const trampoline8 = rscTableCreateOwn.bind(null, handleTable8);
function trampoline9(handle) {
  const handleEntry = rscTableRemove(handleTable8, handle);
  if (handleEntry.own) {
    
    exports0['22'](handleEntry.rep);
  }
}
const trampoline10 = rscTableCreateOwn.bind(null, handleTable10);
function trampoline11(handle) {
  const handleEntry = rscTableRemove(handleTable10, handle);
  if (handleEntry.own) {
    
    exports0['24'](handleEntry.rep);
  }
}
const trampoline12 = rscTableCreateOwn.bind(null, handleTable9);
function trampoline13(handle) {
  const handleEntry = rscTableRemove(handleTable9, handle);
  if (handleEntry.own) {
    
    exports0['23'](handleEntry.rep);
  }
}
const trampoline14 = rscTableCreateOwn.bind(null, handleTable12);
function trampoline15(handle) {
  const handleEntry = rscTableRemove(handleTable12, handle);
  if (handleEntry.own) {
    
    exports0['27'](handleEntry.rep);
  }
}
const trampoline16 = rscTableCreateOwn.bind(null, handleTable13);
function trampoline17(handle) {
  const handleEntry = rscTableRemove(handleTable13, handle);
  if (handleEntry.own) {
    
    exports0['28'](handleEntry.rep);
  }
}
const trampoline18 = rscTableCreateOwn.bind(null, handleTable14);
function trampoline19(handle) {
  const handleEntry = rscTableRemove(handleTable14, handle);
  if (handleEntry.own) {
    
    exports0['29'](handleEntry.rep);
  }
}
const trampoline20 = rscTableCreateOwn.bind(null, handleTable15);
function trampoline21(handle) {
  const handleEntry = rscTableRemove(handleTable15, handle);
  if (handleEntry.own) {
    
    exports0['30'](handleEntry.rep);
  }
}
const trampoline22 = rscTableCreateOwn.bind(null, handleTable16);
function trampoline23(handle) {
  const handleEntry = rscTableRemove(handleTable16, handle);
  if (handleEntry.own) {
    
    exports0['31'](handleEntry.rep);
  }
}
const trampoline24 = rscTableCreateOwn.bind(null, handleTable17);
function trampoline25(handle) {
  const handleEntry = rscTableRemove(handleTable17, handle);
  if (handleEntry.own) {
    
    exports0['32'](handleEntry.rep);
  }
}
const trampoline26 = rscTableCreateOwn.bind(null, handleTable18);
function trampoline27(handle) {
  const handleEntry = rscTableRemove(handleTable18, handle);
  if (handleEntry.own) {
    
    exports0['33'](handleEntry.rep);
  }
}
const trampoline28 = rscTableCreateOwn.bind(null, handleTable19);
function trampoline29(handle) {
  const handleEntry = rscTableRemove(handleTable19, handle);
  if (handleEntry.own) {
    
    exports0['34'](handleEntry.rep);
  }
}
const trampoline30 = rscTableCreateOwn.bind(null, handleTable20);
function trampoline31(handle) {
  const handleEntry = rscTableRemove(handleTable20, handle);
  if (handleEntry.own) {
    
    exports0['35'](handleEntry.rep);
  }
}
const trampoline32 = rscTableCreateOwn.bind(null, handleTable11);
function trampoline33(handle) {
  const handleEntry = rscTableRemove(handleTable11, handle);
  if (handleEntry.own) {
    
    exports0['26'](handleEntry.rep);
  }
}
function trampoline34(handle) {
  const handleEntry = rscTableRemove(handleTable1, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable1.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable1.delete(handleEntry.rep);
    } else if (OutputStream[symbolCabiDispose]) {
      OutputStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline35(handle) {
  const handleEntry = rscTableRemove(handleTable0, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable0.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable0.delete(handleEntry.rep);
    } else if (Error$1[symbolCabiDispose]) {
      Error$1[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline36(handle) {
  const handleEntry = rscTableRemove(handleTable2, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable2.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable2.delete(handleEntry.rep);
    } else if (InputStream[symbolCabiDispose]) {
      InputStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline37(handle) {
  const handleEntry = rscTableRemove(handleTable3, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable3.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable3.delete(handleEntry.rep);
    } else if (Descriptor[symbolCabiDispose]) {
      Descriptor[symbolCabiDispose](handleEntry.rep);
    }
  }
}

const $init = (() => {
  let gen = (function* init () {
    const module0 = fetchCompile(new URL('./solidity_cargo_wasm.component.core.wasm', import.meta.url));
    const module1 = fetchCompile(new URL('./solidity_cargo_wasm.component.core2.wasm', import.meta.url));
    const module2 = fetchCompile(new URL('./solidity_cargo_wasm.component.core3.wasm', import.meta.url));
    const module3 = fetchCompile(new URL('./solidity_cargo_wasm.component.core4.wasm', import.meta.url));
    ({ exports: exports0 } = yield instantiateCore(yield module2));
    ({ exports: exports1 } = yield instantiateCore(yield module0, {
      '[export]nomic-foundation:slang/bindings': {
        '[resource-drop]binding-graph': trampoline33,
        '[resource-drop]built-in-location': trampoline21,
        '[resource-drop]definition': trampoline15,
        '[resource-drop]reference': trampoline17,
        '[resource-drop]user-file-location': trampoline19,
        '[resource-new]binding-graph': trampoline32,
        '[resource-new]built-in-location': trampoline20,
        '[resource-new]definition': trampoline14,
        '[resource-new]reference': trampoline16,
        '[resource-new]user-file-location': trampoline18,
      },
      '[export]nomic-foundation:slang/compilation': {
        '[resource-drop]compilation-unit': trampoline29,
        '[resource-drop]file': trampoline31,
        '[resource-drop]internal-compilation-builder': trampoline27,
        '[resource-new]compilation-unit': trampoline28,
        '[resource-new]file': trampoline30,
        '[resource-new]internal-compilation-builder': trampoline26,
      },
      '[export]nomic-foundation:slang/cst': {
        '[resource-drop]ancestors-iterator': trampoline9,
        '[resource-drop]cursor': trampoline5,
        '[resource-drop]cursor-iterator': trampoline3,
        '[resource-drop]nonterminal-node': trampoline0,
        '[resource-drop]query': trampoline13,
        '[resource-drop]query-match-iterator': trampoline11,
        '[resource-drop]terminal-node': trampoline1,
        '[resource-new]ancestors-iterator': trampoline8,
        '[resource-new]cursor': trampoline4,
        '[resource-new]cursor-iterator': trampoline2,
        '[resource-new]nonterminal-node': trampoline6,
        '[resource-new]query': trampoline12,
        '[resource-new]query-match-iterator': trampoline10,
        '[resource-new]terminal-node': trampoline7,
      },
      '[export]nomic-foundation:slang/parser': {
        '[resource-drop]parse-output': trampoline25,
        '[resource-drop]parser': trampoline23,
        '[resource-new]parse-output': trampoline24,
        '[resource-new]parser': trampoline22,
      },
      wasi_snapshot_preview1: {
        environ_get: exports0['14'],
        environ_sizes_get: exports0['15'],
        fd_write: exports0['13'],
        proc_exit: exports0['16'],
        random_get: exports0['12'],
      },
    }));
    ({ exports: exports2 } = yield instantiateCore(yield module1, {
      __main_module__: {
        cabi_realloc: exports1.cabi_realloc,
      },
      env: {
        memory: exports1.memory,
      },
      'wasi:cli/environment@0.2.3': {
        'get-environment': exports0['0'],
      },
      'wasi:cli/exit@0.2.3': {
        exit: trampoline41,
      },
      'wasi:cli/stderr@0.2.3': {
        'get-stderr': trampoline38,
      },
      'wasi:cli/stdin@0.2.3': {
        'get-stdin': trampoline39,
      },
      'wasi:cli/stdout@0.2.3': {
        'get-stdout': trampoline40,
      },
      'wasi:filesystem/preopens@0.2.3': {
        'get-directories': exports0['11'],
      },
      'wasi:filesystem/types@0.2.3': {
        '[method]descriptor.append-via-stream': exports0['2'],
        '[method]descriptor.get-type': exports0['3'],
        '[method]descriptor.stat': exports0['4'],
        '[method]descriptor.write-via-stream': exports0['1'],
        '[resource-drop]descriptor': trampoline37,
        'filesystem-error-code': exports0['5'],
      },
      'wasi:io/error@0.2.3': {
        '[resource-drop]error': trampoline35,
      },
      'wasi:io/streams@0.2.3': {
        '[method]output-stream.blocking-flush': exports0['9'],
        '[method]output-stream.blocking-write-and-flush': exports0['8'],
        '[method]output-stream.check-write': exports0['6'],
        '[method]output-stream.write': exports0['7'],
        '[resource-drop]input-stream': trampoline36,
        '[resource-drop]output-stream': trampoline34,
      },
      'wasi:random/random@0.2.3': {
        'get-random-bytes': exports0['10'],
      },
    }));
    memory0 = exports1.memory;
    realloc0 = exports2.cabi_import_realloc;
    ({ exports: exports3 } = yield instantiateCore(yield module3, {
      '': {
        $imports: exports0.$imports,
        '0': trampoline42,
        '1': trampoline43,
        '10': trampoline52,
        '11': trampoline53,
        '12': exports2.random_get,
        '13': exports2.fd_write,
        '14': exports2.environ_get,
        '15': exports2.environ_sizes_get,
        '16': exports2.proc_exit,
        '17': exports1['nomic-foundation:slang/cst#[dtor]terminal-kind-extensions'],
        '18': exports1['nomic-foundation:slang/cst#[dtor]nonterminal-node'],
        '19': exports1['nomic-foundation:slang/cst#[dtor]terminal-node'],
        '2': trampoline44,
        '20': exports1['nomic-foundation:slang/cst#[dtor]cursor'],
        '21': exports1['nomic-foundation:slang/cst#[dtor]cursor-iterator'],
        '22': exports1['nomic-foundation:slang/cst#[dtor]ancestors-iterator'],
        '23': exports1['nomic-foundation:slang/cst#[dtor]query'],
        '24': exports1['nomic-foundation:slang/cst#[dtor]query-match-iterator'],
        '25': exports1['nomic-foundation:slang/ast#[dtor]selectors'],
        '26': exports1['nomic-foundation:slang/bindings#[dtor]binding-graph'],
        '27': exports1['nomic-foundation:slang/bindings#[dtor]definition'],
        '28': exports1['nomic-foundation:slang/bindings#[dtor]reference'],
        '29': exports1['nomic-foundation:slang/bindings#[dtor]user-file-location'],
        '3': trampoline45,
        '30': exports1['nomic-foundation:slang/bindings#[dtor]built-in-location'],
        '31': exports1['nomic-foundation:slang/parser#[dtor]parser'],
        '32': exports1['nomic-foundation:slang/parser#[dtor]parse-output'],
        '33': exports1['nomic-foundation:slang/compilation#[dtor]internal-compilation-builder'],
        '34': exports1['nomic-foundation:slang/compilation#[dtor]compilation-unit'],
        '35': exports1['nomic-foundation:slang/compilation#[dtor]file'],
        '36': exports1['nomic-foundation:slang/utils#[dtor]language-facts'],
        '4': trampoline46,
        '5': trampoline47,
        '6': trampoline48,
        '7': trampoline49,
        '8': trampoline50,
        '9': trampoline51,
      },
    }));
    postReturn0 = exports1['cabi_post_nomic-foundation:slang/cst#[method]cursor.children'];
    postReturn1 = exports1['cabi_post_nomic-foundation:slang/bindings#[method]user-file-location.file-id'];
    realloc1 = exports1.cabi_realloc;
    postReturn2 = exports1['cabi_post_nomic-foundation:slang/ast#[static]selectors.choice'];
    postReturn3 = exports1['cabi_post_nomic-foundation:slang/cst#[method]query-match-iterator.next'];
    postReturn4 = exports1['cabi_post_nomic-foundation:slang/ast#[static]selectors.sequence'];
    postReturn5 = exports1['cabi_post_nomic-foundation:slang/ast#[static]selectors.repeated'];
    postReturn6 = exports1['cabi_post_nomic-foundation:slang/ast#[static]selectors.separated'];
    postReturn7 = exports1['cabi_post_nomic-foundation:slang/bindings#[method]definition.references'];
    postReturn8 = exports1['cabi_post_nomic-foundation:slang/compilation#[method]file.errors'];
    postReturn9 = exports1['cabi_post_nomic-foundation:slang/utils#[static]language-facts.all-versions'];
    cstStaticTerminalKindExtensionsIsIdentifier = exports1['nomic-foundation:slang/cst#[static]terminal-kind-extensions.is-identifier'];
    cstStaticTerminalKindExtensionsIsTrivia = exports1['nomic-foundation:slang/cst#[static]terminal-kind-extensions.is-trivia'];
    cstStaticTerminalKindExtensionsIsValid = exports1['nomic-foundation:slang/cst#[static]terminal-kind-extensions.is-valid'];
    cstMethodNonterminalNodeId = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.id'];
    cstMethodNonterminalNodeKind = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.kind'];
    cstMethodNonterminalNodeTextLength = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.text-length'];
    cstMethodNonterminalNodeChildren = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.children'];
    cstMethodNonterminalNodeDescendants = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.descendants'];
    cstMethodNonterminalNodeUnparse = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.unparse'];
    cstMethodNonterminalNodeToJson = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.to-json'];
    cstMethodNonterminalNodeCreateCursor = exports1['nomic-foundation:slang/cst#[method]nonterminal-node.create-cursor'];
    cstMethodTerminalNodeId = exports1['nomic-foundation:slang/cst#[method]terminal-node.id'];
    cstMethodTerminalNodeKind = exports1['nomic-foundation:slang/cst#[method]terminal-node.kind'];
    cstMethodTerminalNodeTextLength = exports1['nomic-foundation:slang/cst#[method]terminal-node.text-length'];
    cstMethodTerminalNodeChildren = exports1['nomic-foundation:slang/cst#[method]terminal-node.children'];
    cstMethodTerminalNodeDescendants = exports1['nomic-foundation:slang/cst#[method]terminal-node.descendants'];
    cstMethodTerminalNodeUnparse = exports1['nomic-foundation:slang/cst#[method]terminal-node.unparse'];
    cstMethodTerminalNodeToJson = exports1['nomic-foundation:slang/cst#[method]terminal-node.to-json'];
    cstMethodCursorReset = exports1['nomic-foundation:slang/cst#[method]cursor.reset'];
    cstMethodCursorComplete = exports1['nomic-foundation:slang/cst#[method]cursor.complete'];
    cstMethodCursorIsCompleted = exports1['nomic-foundation:slang/cst#[method]cursor.is-completed'];
    cstMethodCursorClone = exports1['nomic-foundation:slang/cst#[method]cursor.clone'];
    cstMethodCursorSpawn = exports1['nomic-foundation:slang/cst#[method]cursor.spawn'];
    cstMethodCursorNode = exports1['nomic-foundation:slang/cst#[method]cursor.node'];
    cstMethodCursorLabel = exports1['nomic-foundation:slang/cst#[method]cursor.label'];
    cstMethodCursorTextOffset = exports1['nomic-foundation:slang/cst#[method]cursor.text-offset'];
    cstMethodCursorTextRange = exports1['nomic-foundation:slang/cst#[method]cursor.text-range'];
    cstMethodCursorDepth = exports1['nomic-foundation:slang/cst#[method]cursor.depth'];
    cstMethodCursorChildren = exports1['nomic-foundation:slang/cst#[method]cursor.children'];
    cstMethodCursorDescendants = exports1['nomic-foundation:slang/cst#[method]cursor.descendants'];
    cstMethodCursorRemainingNodes = exports1['nomic-foundation:slang/cst#[method]cursor.remaining-nodes'];
    cstMethodCursorAncestors = exports1['nomic-foundation:slang/cst#[method]cursor.ancestors'];
    cstMethodCursorGoToNext = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next'];
    cstMethodCursorGoToNextNonDescendant = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-non-descendant'];
    cstMethodCursorGoToPrevious = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-previous'];
    cstMethodCursorGoToParent = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-parent'];
    cstMethodCursorGoToFirstChild = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-first-child'];
    cstMethodCursorGoToLastChild = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-last-child'];
    cstMethodCursorGoToNthChild = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-nth-child'];
    cstMethodCursorGoToNextSibling = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-sibling'];
    cstMethodCursorGoToPreviousSibling = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-previous-sibling'];
    cstMethodCursorGoToNextTerminal = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-terminal'];
    cstMethodCursorGoToNextTerminalWithKind = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-terminal-with-kind'];
    cstMethodCursorGoToNextTerminalWithKinds = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-terminal-with-kinds'];
    cstMethodCursorGoToNextNonterminal = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-nonterminal'];
    cstMethodCursorGoToNextNonterminalWithKind = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-nonterminal-with-kind'];
    cstMethodCursorGoToNextNonterminalWithKinds = exports1['nomic-foundation:slang/cst#[method]cursor.go-to-next-nonterminal-with-kinds'];
    cstMethodCursorQuery = exports1['nomic-foundation:slang/cst#[method]cursor.query'];
    cstMethodCursorIteratorNext = exports1['nomic-foundation:slang/cst#[method]cursor-iterator.next'];
    cstMethodAncestorsIteratorNext = exports1['nomic-foundation:slang/cst#[method]ancestors-iterator.next'];
    cstStaticQueryCreate = exports1['nomic-foundation:slang/cst#[static]query.create'];
    cstMethodQueryMatchIteratorNext = exports1['nomic-foundation:slang/cst#[method]query-match-iterator.next'];
    astStaticSelectorsSequence = exports1['nomic-foundation:slang/ast#[static]selectors.sequence'];
    astStaticSelectorsChoice = exports1['nomic-foundation:slang/ast#[static]selectors.choice'];
    astStaticSelectorsRepeated = exports1['nomic-foundation:slang/ast#[static]selectors.repeated'];
    astStaticSelectorsSeparated = exports1['nomic-foundation:slang/ast#[static]selectors.separated'];
    bindingsMethodBindingGraphDefinitionAt = exports1['nomic-foundation:slang/bindings#[method]binding-graph.definition-at'];
    bindingsMethodBindingGraphReferenceAt = exports1['nomic-foundation:slang/bindings#[method]binding-graph.reference-at'];
    bindingsMethodDefinitionId = exports1['nomic-foundation:slang/bindings#[method]definition.id'];
    bindingsMethodDefinitionNameLocation = exports1['nomic-foundation:slang/bindings#[method]definition.name-location'];
    bindingsMethodDefinitionDefiniensLocation = exports1['nomic-foundation:slang/bindings#[method]definition.definiens-location'];
    bindingsMethodDefinitionReferences = exports1['nomic-foundation:slang/bindings#[method]definition.references'];
    bindingsMethodReferenceId = exports1['nomic-foundation:slang/bindings#[method]reference.id'];
    bindingsMethodReferenceLocation = exports1['nomic-foundation:slang/bindings#[method]reference.location'];
    bindingsMethodReferenceDefinitions = exports1['nomic-foundation:slang/bindings#[method]reference.definitions'];
    bindingsMethodUserFileLocationFileId = exports1['nomic-foundation:slang/bindings#[method]user-file-location.file-id'];
    bindingsMethodUserFileLocationCursor = exports1['nomic-foundation:slang/bindings#[method]user-file-location.cursor'];
    parserStaticParserCreate = exports1['nomic-foundation:slang/parser#[static]parser.create'];
    parserMethodParserLanguageVersion = exports1['nomic-foundation:slang/parser#[method]parser.language-version'];
    parserMethodParserParseFileContents = exports1['nomic-foundation:slang/parser#[method]parser.parse-file-contents'];
    parserMethodParserParseNonterminal = exports1['nomic-foundation:slang/parser#[method]parser.parse-nonterminal'];
    parserMethodParseOutputTree = exports1['nomic-foundation:slang/parser#[method]parse-output.tree'];
    parserMethodParseOutputErrors = exports1['nomic-foundation:slang/parser#[method]parse-output.errors'];
    parserMethodParseOutputIsValid = exports1['nomic-foundation:slang/parser#[method]parse-output.is-valid'];
    parserMethodParseOutputCreateTreeCursor = exports1['nomic-foundation:slang/parser#[method]parse-output.create-tree-cursor'];
    compilationStaticInternalCompilationBuilderCreate = exports1['nomic-foundation:slang/compilation#[static]internal-compilation-builder.create'];
    compilationMethodInternalCompilationBuilderAddFile = exports1['nomic-foundation:slang/compilation#[method]internal-compilation-builder.add-file'];
    compilationMethodInternalCompilationBuilderResolveImport = exports1['nomic-foundation:slang/compilation#[method]internal-compilation-builder.resolve-import'];
    compilationMethodInternalCompilationBuilderBuild = exports1['nomic-foundation:slang/compilation#[method]internal-compilation-builder.build'];
    compilationMethodCompilationUnitLanguageVersion = exports1['nomic-foundation:slang/compilation#[method]compilation-unit.language-version'];
    compilationMethodCompilationUnitFiles = exports1['nomic-foundation:slang/compilation#[method]compilation-unit.files'];
    compilationMethodCompilationUnitFile = exports1['nomic-foundation:slang/compilation#[method]compilation-unit.file'];
    compilationMethodCompilationUnitBindingGraph = exports1['nomic-foundation:slang/compilation#[method]compilation-unit.binding-graph'];
    compilationMethodFileId = exports1['nomic-foundation:slang/compilation#[method]file.id'];
    compilationMethodFileTree = exports1['nomic-foundation:slang/compilation#[method]file.tree'];
    compilationMethodFileErrors = exports1['nomic-foundation:slang/compilation#[method]file.errors'];
    compilationMethodFileCreateTreeCursor = exports1['nomic-foundation:slang/compilation#[method]file.create-tree-cursor'];
    utilsStaticLanguageFactsAllVersions = exports1['nomic-foundation:slang/utils#[static]language-facts.all-versions'];
    utilsStaticLanguageFactsEarliestVersion = exports1['nomic-foundation:slang/utils#[static]language-facts.earliest-version'];
    utilsStaticLanguageFactsLatestVersion = exports1['nomic-foundation:slang/utils#[static]language-facts.latest-version'];
    utilsStaticLanguageFactsInferLanguageVersions = exports1['nomic-foundation:slang/utils#[static]language-facts.infer-language-versions'];
  })();
  let promise, resolve, reject;
  function runNext (value) {
    try {
      let done;
      do {
        ({ value, done } = gen.next(value));
      } while (!(value instanceof Promise) && !done);
      if (done) {
        if (resolve) resolve(value);
        else return value;
      }
      if (!promise) promise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));
      value.then(runNext, reject);
    }
    catch (e) {
      if (reject) reject(e);
      else throw e;
    }
  }
  const maybeSyncReturn = runNext(null);
  return promise || maybeSyncReturn;
})();

await $init;
const ast = {
  Selectors: Selectors,
  
};
const bindings = {
  BindingGraph: BindingGraph,
  BindingLocationType: BindingLocationType,
  Definition: Definition,
  Reference: Reference,
  UserFileLocation: UserFileLocation,
  
};
const compilation = {
  CompilationUnit: CompilationUnit,
  File: File,
  InternalCompilationBuilder: InternalCompilationBuilder,
  
};
const cst = {
  AncestorsIterator: AncestorsIterator,
  Cursor: Cursor,
  CursorIterator: CursorIterator,
  EdgeLabel: edgeLabel,
  NodeType: NodeType,
  NonterminalKind: nonterminalKind,
  NonterminalNode: NonterminalNode,
  Query: Query,
  QueryMatchIterator: QueryMatchIterator,
  TerminalKind: terminalKind,
  TerminalKindExtensions: TerminalKindExtensions,
  TerminalNode: TerminalNode,
  
};
const parser = {
  ParseOutput: ParseOutput,
  Parser: Parser,
  
};
const utils = {
  LanguageFacts: LanguageFacts,
  
};

export { ast, bindings, compilation, cst, parser, utils,  }